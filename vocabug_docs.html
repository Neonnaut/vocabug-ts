<!DOCTYPE html>
<html lang="en-AU" id="colour-target" class="dark-mode">
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta charset="UTF-8">
  <!-- Website information -->
  <title>Vocabug docs</title>
  <meta name="description" content="A tool to generate words.">
  <meta name="keywords" content="conlangs">
  <meta name="author" content="Neonnaut">
  <!-- Scripts and stylings -->
  <link href="style.css" rel="stylesheet" type="text/css" media="all">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
  <script src="script/theme-picker.js"></script>

  <!-- Fonts -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  <!-- Icons -->

</head>
<body>
  <nav id="myNav">
    <ol class="breadcrumbs">
      <li>
        <a href="/"><img alt="neocities favicon" src="./img/neonnaut.png"></a>
      </li>
      <li style="float: right;">
        <button id="main_menu"><i class="fa fa-bars"></i> Menu</button>
      </li>
    </ol>
  </nav>

  <div id="content">
    <section id="top">
      <div>
        <img src="img/vocabug_logo.svg" alt="Logo of letter V with bug antennae" style="float: left;">

        <h1 style="margin-bottom: 10px;">Vocabug<br>docs</h1>
        <b>Version: 0.3.3</b>
      </div>
      <br>

      <h2>Contents</h2>
      <ol class="nice-list">
        <li><a href="#vocAbout">About Vocabug</a></li>
        <li><a href="#vocInterface">Interface</a>
        <ol class="nice-list">
          <li><a href="#vocOptions">Options</a></li>
          <li><a href="#vocSaveLoad">File save / load</a></li> 
        </ol>
        </li>
        <li><a href="#vocComments">Using comments</a></li>
        <li><a href="#vocAboutGraphemes">About graphemes</a>
        <ol class="nice-list">
          <li><a href="#vocNullGrapheme">Null grapheme</a></li>
          

          <li><a href="#vocEscapingCharacters">Escaping characters</a>
          <ol class="nice-list">
            <li><a href="#vocEscapeWord">Word creation character escape</a></li>
            <li><a href="#vocEscapeTransform">Transform character escape</a></li>
            <li><a href="#vocNamedEscape">Named escape</a></li>
          </ol>
          </li>
          
        </ol>
        </li>

        <li><a href="#vocCategories">Categories</a>
        <ol class="nice-list">
          <li><a href="#vocCategoryinCategory">Categories inside categories and category-sets</a></li>
        </ol>
        </li>

        <li><a href="#vocBuildingWords">Building words</a>
        <ol class="nice-list">
          <li><a href="#vocWords">Words</a></li>
        
          <li><a href="#vocSegments">Segments</a></li>
          <li><a href="#vocPickOne">Pick-one-set</a></li>
          <li><a href="#vocOptional">Optional-set</a>
          <ol class="nice-list">
            <li><a href="#vocOptionalsWeight">Optional weight</a></li>
          </ol>
          </li>
          <li><a href="#vocSupraSet">Supra-set</a>
          <ol class="nice-list">
            <li><a href="#vocSupraSetWeight">Supra-set weight</a></li>
          </ol>
          </li>
        </ol>
        </li>
        <li><a href="#vocDistributions">Default distributions</a></li>
        <li><a href="#vocAssigningWeights">Assigning weights</a></li>
        <li><a href="#vocAlphabetisation">Alphabetisation</a>
        <ol class="nice-list">
          <li><a href="#vocInvisibility">Invisibility</a></li>
        </ol>
        </li>
        <li><a href="#vocGraphemes">Defining graphemes</a></li>
        <li><a href="#nescaTransform">Transform</a></li>
        <li><a href="#nescaTheChange">The change</a>
        <ol class="nice-list">
          <li><a href="#nescaConcurrentChange">Concurrent change</a></li>
          <li><a href="#nescaMergingChange">Merging change</a></li>
          <li><a href="#nescaReject">Reject</a></li>
          
        </ol>
        </li>

        <li><a href="#nescaInsertionAndDeletion">Insertion and deletion</a></li>

        <li><a href="#nescaTheCondition">The condition</a>
        <ol class="nice-list">
          <li><a href="#nescaMultipleCondition">Multiple conditions in one rule</a></li>
          <li><a href="#nescaWordBoundary">Word boundary</a></li>
          <li><a href="#nescaChanceCondition">The chance condition</a></li>
        </ol>
        </li>

        <li><a href="#nescaTheException">The exception</a></li>

        <li><a href="#nescaUsingCategories">Using categories</a></li>

        <li><a href="#nescaFeatures">Features</a>
        <ol class="nice-list">
          <li><a href="#nescaProFeature">Pro-feature</a></li>
          <li><a href="#nescaAntiFeature">Anti-feature</a></li>
          <li><a href="#nescaParaFeature">Para-feature</a></li>
          <li><a href="#nescaFeatureInFeature">Referencing featues inside features</a></li>
          <li><a href="#nescaUsingFeatures">Using features</a></li>
          <li><a href="#nescaFeatureField">Feature-field</a></li>
        </ol>
        </li>

        <li><a href="#nescaAltAndOpt">Alternator and Optionalator</a>
        <ol class="nice-list">
          <li><a href="#nescaAlternatorSet">Alternator-set</a></li>
          <li><a href="#nescaOptionalatorSet">Optionalator-set</a></li>
        </ol>
        </li>

        <li><a href="#nescaClusterfield">Cluster-field</a></li>

        <li><a href="#nescaWildcardsAndQuantifiers">Wildcards and quantifiers</a>
        <ol class="nice-list">
          <li><a href="#nescaQuantifier">Quantifier</a></li>
          <li><a href="#nescaBoundedQuantifier">Bounded quantifier</a></li>
          <li><a href="#nescaKleeneStar">Kleene-star</a></li>
          <li><a href="#nescaGeminateMark">Geminate-mark</a></li>
          <li><a href="#nescaWildcard">Wildcard</a></li>
          <li><a href="#nescaAnythingsMark">Anythings-mark</a></li>
          <li><a href="#nescaBlocker">Blocked-anythings-mark</a></li>
        </ol>
        </li>

        <li><a href="#nescaAdvancedRules">Advanced rules</a>
          <ol class="nice-list">
            <li><a href="#nescaTargetReference">Target-reference</a></li>
            <li><a href="#nescaNamedReference">Named-reference</a></li>
            <li><a href="#nescaMetathesisChange">Metathesis change</a></li>
            <li><a href="#nescaEngine">Engine</a></li>
        </ol>
        </li>
        <li><a href="#vocabugQuestionsAndAnswers">Questions and answers</a></li>
      </ol>

      <h2 id="vocAbout"><a class="head-num">1</a>About Vocabug</h2>
      <p>This is the complete documentation for <a href="./vocabug.html">Vocabug, version: 0.3.3</a>. Vocabug randomly generates vocabulary from a given definition of graphemes and word patterns. It can be used to generate words for a constructed language, original nicknames or passwords, or just for fun.</p>

      <p>This word generator is designed to be a successor to the Williams' <a href="https://github.com/bbrk24/lexifer-ts">Lexifer</a> and to the legendary <a href="https://github.com/nai888/awkwords">Awkwords</a>. You can find Vocabug's repository <a href="https://github.com/Neonnaut/vocabug-ts">here</a>. If you want a "modern" user interface, albeit with limited features, check out <a href="https://neonnaut.neocities.org/vocabug-lite">Vocabug-lite</a>.</p>

      <h2 id="vocInterface"><a class="head-num">2</a>Interface</h2>
      <ul class="paragraphian">
        <li>The textbox at the bottom of the program is the <code class="example">definition-build editor</code>. A definition-build defines the graphemes, frequencies, word-shapes and transforms that generate the final words. There will already be a default definition-build in the definition-build editor, or the previous definition-build that generated words</li>
        <li>Use the <code class="example">Generate</code> button to see Vocabug produce words</li>
        <li>Use the <code class="example">Copy</code> button to copy the words to the clipboard</li>
        <li>Use the <code class="example">Clear</code> button to clear the definition-build editor and the generated words</li>
      </ul>

      <h3 id="vocOptions"><a class="head-num">2.1</a>Options</h3>
      <ul class="paragraphian">
        <li>Use the <code class="example">Number of words</code> textbox to choose the number of words to generate. The default number is 100</li>
        <li><code class="example">Word-list mode</code> will produce a list of words</li>
        <li><code class="example">Paragraph mode</code> will produce words that look vaguely like sentences by injecting punctuation into the word list and capitalising the first word of each sentence</li>
        <li><code class="example">Debug mode</code> will show, line by line, each step in creating each word</li>
        <li><code class="example">Editor wrap lines</code> will make the definition-build editor jump to the next line if the line escapes the width of the definition-build editor</li>
        <li><code class="example">Show keyboard</code> will reveal a 'keyboard', a character selector, below the editor</li>
        <li><code class="example">Remove duplicates</code> will make sure all words generated are unique</li>
        <li><code class="example">Force words</code> will force the generator to try and generate the complete number of words requested within 30 seconds, despite the number of rejections / duplicates removed</li>
        <li><code class="example">Sort words</code> sorts the words in alphabetical order, or the order defined in the <code class="example">alphabet:</code> directive</li>
        <li>The <code class="example">Word divider</code> textbox sets the delimiter, or in other words, what the content will be between each word in the output. It is a space "<code class="example"> </code>" by default. Use <code class="example">\n</code> to get one word for each line</li>
      </ul>

      <h3 id="vocSaveLoad"><a class="head-num">2.2</a>File save / load</h3>
      <ul class="paragraphian">
        <li>Use the <code class="example">Save</code> button to download the definition-build as a file called 'vocabug.txt', or whatever you named your file in the <code class="example">File name:</code> field. The file is always a ".txt" type</li>
        <li>Use the <code class="example">Load</code> button to load a file from your system into the definition-build editor</li>
        <li>Use the buttons in the <code class="example">Examples</code> dropdown to load an example into the definition-build editor</li>
      </ul>
      
      <h2 id="vocComments"><a class="head-num">3</a>Using comments</h2>
      <p>If a line contains a semicolon <code class="example">;</code> everything after it on that line is ignored and not interpreted as Vocabug syntax -- unless <code class="example">;</code> is <a href="#vocEscapeWord">escaped</a>. You can use this to leave notes about what something does or why you made certain decisions.</p>

      <h2 id="vocAboutGraphemes"><a class="head-num">4</a>About graphemes</h2>
      <p>Graphemes are indivisible meaningful characters that make a generated word in Vocabug. Phonemes can be thought of as graphemes. If we use English words <code class="example">sky</code> and <code class="example">shy</code> as examples to illustrate this, <code class="example">sky</code> is made up by the graphemes <code class="example">s</code> + <code class="example">k</code> + <code class="example">y</code>, while <code class="example">shy</code> is made up by <code class="example">sh</code> + <code class="example">y</code>.</p>

      <h3 id="vocNullGrapheme"><a class="head-num">4.1</a>Null grapheme</h3>
      <p>If a word is built using the syntax character <code class="example">^</code> or <code class="example">∅</code>, it will disappear in the generated word. In other words <code class="example">^</code> is a null grapheme. If you want to use <code class="example">^</code> as a grapheme, you will need to <a href="#vocEscapeWord">escape it</a>. To use other syntax characters as graphemes, they must be escaped too.</p>

      <h3 id="vocEscapingCharacters"><a class="head-num">4.2</a>Escaping characters</h3>
      <p>A single-length character following the syntax character <code class="example">\</code> ignores any meaning it might have had in the generator, including backslashes themselves. This way, anything including capital letters that have already been defined as categories, brackets, even spaces can be graphemes.</p>

      <h4 id="vocEscapeWord"><a class="head-num">4.2.1</a>Word creation character escape</h4>
      <p>These are the characters you must escape if you want to use them in <a href="#vocCategories">categories</a>, <a href="#vocSegments">segments</a> and the <a href="#vocWords">words</a> directive:</p>
      <table class="styled-table">
        <thead>
          <tr>
            <th>Characters</th>
            <th>Meaning</th>
          </tr>
        </thead>

        <tbody>
          
          <tr>
            <td><code class="example">;</code></td>
            <td><a href="#vocComments">Comment</a></td>
          </tr>
          <tr>
            <td><code class="example">\</code></td>
            <td>Escapes a character after it</td>
          </tr>
          <tr>
            <td><code class="example">[@</code> and <code class="example">]</code></td>
            <td>Named escape</td>
          </tr>
          <tr>
            <td><code class="example">C</code>, <code class="example">D</code>, <code class="example">K</code>, ...</td>
            <td>Any one-length capital letter can refer to a <a href="#vocCategories">category</a></td>
          </tr>
          <tr>
            <td><code class="example">+</code> or <code class="example">-</code> or <code class="example">&gt;</code>... </td>
            <td>A <a href="#nescaFeatures">feature</a></td>
          </tr>
          <tr>
            <td><code class="example">+-</code> </td>
            <td>Begins a <a href="#nescaFeatureField">feature-field</a></td>
          </tr>
          <tr>
            <td><code class="example">$</code></td>
            <td>Defines a <a href="#vocSegments">segment</a> when followed by a capital letter</td>
          </tr>
          <tr>
            <td><code class="example">,</code> or <code class="example">&nbsp;</code></td>
            <td>Separates choices</td>
          </tr>
          <tr>
            <td><code class="example">*</code></td>
            <td>Gives <a href="#vocAssigningWeights">weight</a> to an item</td>
          </tr>
          <tr>
            <td><code class="example">{</code> and <code class="example">}</code></td>
            <td><a href="#vocPickOne">Pick-one-set</a></td>
          </tr>
          <tr>
            <td><code class="example">(</code> and <code class="example">)</code></td>
            <td><a href="#vocOptional">Optional-set</a></td>
          </tr>
          <tr>
            <td><code class="example">&lt;</code> and <code class="example">&gt;</code></td>
            <td><a href="#vocSupraSet">Supra-set item</a></td>
          </tr>
          <tr>
            <td><code class="example">^</code> or <code class="example">∅</code></td>
            <td>A null grapheme</td>
          </tr>
        </tbody>
      </table>

      <h4 id="vocEscapeTransform"><a class="head-num">4.2.2</a>Transform character escape</h4>
      <p>These are the characters you must escape if you want to use them in the <a href="#nescaTransform">transform</a> block:</p>
      <table class="styled-table">
        <thead>
          <tr>
            <th>Characters</th>
            <th>Meaning</th>
          </tr>
        </thead>

        <tbody>
          <tr>
            <td><code class="example">;</code></td>
            <td><a href="#vocComments">Comment</a></td>
          </tr>
          <tr>
            <td><code class="example">\</code></td>
            <td>Escapes a character after it</td>
          </tr>
          <tr>
            <td><code class="example">[@</code> and <code class="example">]</code></td>
            <td>Named escape</td>
          </tr>
          <tr>
            <td><code class="example">&gt;</code>, <code class="example">-&gt;</code>, <code class="example">=&gt;</code>, <code class="example">⇒</code> or <code class="example">→</code></td>
            <td>Indicates <a href="#nescaTheChange">change</a></td>
          </tr>
          <tr>
            <td><code class="example">,</code> or <code class="example">&nbsp;</code></td>
            <td>Separates choices</td>
          </tr>
          <tr>
            <td><code class="example">{</code> and <code class="example">}</code></td>
            <td><a href="#nescaAlternatorSet">Alternator-set</a></td>
          </tr>
          <tr>
            <td><code class="example">(</code> and <code class="example">)</code></td>
            <td><a href="#nescaOptionalatorSet">Optionalator-set</a></td>
          </tr>
          <tr>
            <td><code class="example">C</code>, <code class="example">D</code>, <code class="example">K</code>, ...</td>
            <td>Any one-length capital letter can refer to a <a href="#nescaUsingCategories">category</a></td>
          </tr>
          <tr>
            <td><code class="example">[+</code> or <code class="example">[-</code> and <code class="example">]</code></td>
            <td><a href="#nescaUsingFeatures">Feature</a> matrix</td>
          </tr>
          <tr>
            <td><code class="example">^</code> or <code class="example">∅</code></td>
            <td><a href="#nescaInsertionAndDeletion">Insertion</a> when in <code class="example">TARGET</code>, <a href="#nescaInsertionAndDeletion">deletion</a> when in <code class="example">RESULT</code></td>
          </tr>
          <tr>
            <td><code class="example">^REJECT</code> or <code class="example">^R</code></td>
            <td><a href="#nescaReject">Rejects</a> a word</td>
          </tr>
          <tr>
            <td><code class="example">/</code></td>
            <td>A <a href="#nescaTheCondition">condition</a> follows this character</td>
          </tr>
          <tr>
            <td><code class="example">?</code></td>
            <td>A <a href="#nescaChanceCondition"> chance condition</a> follows this character</td>
          </tr>
          <tr>
            <td><code class="example">!</code> or <code class="example">//</code></td>
            <td>An <a href="#nescaTheException">exception</a> follows this character</td>
          </tr>
          <tr>
            <td><code class="example">_</code></td>
            <td>The underscore <code class="example">_</code> is a reference to the target</td>
          </tr>
          <tr>
            <td><code class="example">#</code></td>
            <td><a href="#nescaWordBoundary">Word boundary</a></td>
          </tr>
          <tr>
            <td><code class="example">+</code></td>
            <td><a href="#nescaQuantifier">Quantifier</a>, matches as 1 or more of the previous grapheme</td>
          </tr>
          <tr>
            <td><code class="example">+[</code> and <code class="example">]</code></td>
            <td><a href="#nescaBoundedQuantifier">Bounded quantifier</a></td>
          </tr>
          <tr>
            <td><code class="example">:</code></td>
            <td><a href="#nescaGeminateMark">Geminate-mark</a>, matches twice to the previous grapheme</td>
          </tr>
          <tr>
            <td><code class="example">*</code></td>
            <td><a href="#nescaWildcard">Wildcard</a>, matches exactly 1 of any grapheme</td>
          </tr>
          <tr>
            <td><code class="example">&</code> or <code class="example">…</code></td>
            <td><a href="#nescaAnythingsMark">Anythings-mark</a>, matches ungreedily 1 or more wildcards</td>
          </tr>
          <tr>
            <td><code class="example">&[</code> or <code class="example">…[</code> and <code class="example">]</code></td>
            <td><a href="#nescaBlocker">Blocked-anythings-mark</a></td>
          </tr>
          <tr>
            <td><code class="example">$</code></td>
            <td><a href="#nescaTargetReference">Target-reference</a></td>
          </tr>
          <tr>
            <td><code class="example">=[</code> and <code class="example">]</code></td>
            <td><a href="#nescaNamedReference">Named-capture</a></td>
          </tr>
          <tr>
            <td><code class="example">[$</code> and <code class="example">]</code></td>
            <td><a href="#nescaNamedReference">Named-reference</a></td>
          </tr>
          <tr>
            <td><code class="example">&lt;</code></td>
            <td>Indicates a <a href="#nescaMetathesisChange">metathesis</a> change</td>
          </tr>
          <tr>
            <td><code class="example">|</code></td>
            <td><a href="#nescaEngine">Engines</a> are placed after this character, and a space</td>
          </tr>
        </tbody>
      </table>


      <h4 id="vocNamedEscape"><a class="head-num">4.2.3</a>Named escape</h4>
      <p>Named escapes, enclosed in <code class="example">[@</code> and <code class="example">]</code> allow space and combining diacritics to be used without needing to insert these characters.</p>

      <p>The supported characters are:</p>
      <table class="styled-table"><thead><thead>
        <tr>
          <th>Escape Name</th>
          <th>Unicode Character</th>
        </tr></thead>
      <tbody>
        <tr>
          <td><code class='example'>[@Space]</code></td>
          <td> </td>
        </tr>
        <tr>
          <td><code class='example'>[@Acute]</code></td>
          <td>◌́</td>
        </tr>
        <tr>
          <td><code class='example'>[@DoubleAcute]</code></td>
          <td>◌̋</td>
        </tr>
        <tr>
          <td><code class='example'>[@Grave]</code></td>
          <td>◌̀</td>
        </tr>
        <tr>
          <td><code class='example'>[@DoubleGrave]</code></td>
          <td>◌̏</td>
        </tr>
        <tr>
          <td><code class='example'>[@Circumflex]</code></td>
          <td>◌̂</td>
        </tr>
        <tr>
          <td><code class='example'>[@Caron]</code></td>
          <td>◌̌</td>
        </tr>
        <tr>
          <td><code class='example'>[@Breve]</code></td>
          <td>◌̆</td>
        </tr>
        <tr>
          <td><code class='example'>[@BreveBelow]</code></td>
          <td>◌̮</td>
        </tr>
        <tr>
          <td><code class='example'>[@InvertedBreve]</code></td>
          <td>◌̑</td>
        </tr>
        <tr>
          <td><code class='example'>[@InvertedBreveBelow]</code></td>
          <td>◌̯</td>
        </tr>
        <tr>
          <td><code class='example'>[@TildeAbove]</code></td>
          <td>◌̃</td>
        </tr>
        <tr>
          <td><code class='example'>[@TildeBelow]</code></td>
          <td>◌̰</td>
        </tr>
        <tr>
          <td><code class='example'>[@Macron]</code></td>
          <td>◌̄</td>
        </tr>
        <tr>
          <td><code class='example'>[@MacronBelow]</code></td>
          <td>◌̠</td>
        </tr>
        <tr>
          <td><code class='example'>[@MacronBelowStandalone]</code></td>
          <td>◌˗</td>
        </tr>
        <tr>
          <td><code class='example'>[@Dot]</code></td>
          <td>◌̇</td>
        </tr>
        <tr>
          <td><code class='example'>[@DotBelow]</code></td>
          <td>◌̣</td>
        </tr>
        <tr>
          <td><code class='example'>[@Diaeresis]</code></td>
          <td>◌̈</td>
        </tr>
        <tr>
          <td><code class='example'>[@DiaeresisBelow]</code></td>
          <td>◌̤</td>
        </tr>
        <tr>
          <td><code class='example'>[@Ring]</code></td>
          <td>◌̊</td>
        </tr>
        <tr>
          <td><code class='example'>[@RingBelow]</code></td>
          <td>◌̥</td>
        </tr>
        <tr>
          <td><code class='example'>[@Horn]</code></td>
          <td>◌̛</td>
        </tr>
        <tr>
          <td><code class='example'>[@Hook]</code></td>
          <td>◌̉</td>
        </tr>
        <tr>
          <td><code class='example'>[@CommaAbove]</code></td>
          <td>◌̓</td>
        </tr>
        <tr>
          <td><code class='example'>[@CommaBelow]</code></td>
          <td>◌̦</td>
        </tr>
        <tr>
          <td><code class='example'>[@Cedilla]</code></td>
          <td>◌̧</td>
        </tr>
        <tr>
          <td><code class='example'>[@Ogonek]</code></td>
          <td>◌̨</td>
        </tr>
        <tr>
          <td><code class='example'>[@VerticalLineBelow]</code></td>
          <td>◌̩</td>
        </tr>
        <tr>
          <td><code class='example'>[@VerticalLineAbove]</code></td>
          <td>◌̍</td>
        </tr>
        <tr>
          <td><code class='example'>[@DoubleVerticalLineBelow]</code></td>
          <td>◌͈</td>
        </tr>
        <tr>
          <td><code class='example'>[@PlusSignBelow]</code></td>
          <td>◌̟</td>
        </tr>
        <tr>
          <td><code class='example'>[@PlusSignStandalone]</code></td>
          <td>◌˖</td>
        </tr>
        <tr>
          <td><code class='example'>[@uptackBelow]</code></td>
          <td>◌̝</td>
        </tr>
        <tr>
          <td><code class='example'>[@UpTackStandalone]</code></td>
          <td>◌˔</td>
        </tr>
        <tr>
          <td><code class='example'>[@LeftTackBelow]</code></td>
          <td>◌̘</td>
        </tr>
        <tr>
          <td><code class='example'>[@rightTackBelow]</code></td>
          <td>◌̙</td>
        </tr>
        <tr>
          <td><code class='example'>[@DownTackBelow]</code></td>
          <td>◌̞</td>
        </tr>
        <tr>
          <td><code class='example'>[@DownTackStandalone]</code></td>
          <td>◌˕</td>
        </tr>
        <tr>
          <td><code class='example'>[@BridgeBelow]</code></td>
          <td>◌̪</td>
        </tr>
        <tr>
          <td><code class='example'>[@BridgeAbove]</code></td>
          <td>◌͆</td>
        </tr>
        <tr>
          <td><code class='example'>[@InvertedBridgeBelow]</code></td>
          <td>◌̺</td>
        </tr>
        <tr>
          <td><code class='example'>[@SquareBelow]</code></td>
          <td>◌̻</td>
        </tr>
        <tr>
          <td><code class='example'>[@SeagullBelow]</code></td>
          <td>◌̼</td>
        </tr>
        <tr>
          <td><code class='example'>[@LeftBracketBelow]</code></td>
          <td>◌͉</td>
        </tr>
      </tbody></table>
      <p>If you are using this, you should be very interested in the <a href="#nescaEngine">Compose engine</a>.</p>

      <h2 id="vocCategories"><a class="head-num">5</a>Categories</h2>
      <p>A category is a set of <a href="#vocAboutGraphemes">graphemes</a> with a key. The key is a singular-length capital letter. For example:</p>
      <div class="prog-pre"><span class="catkey">C</span> <span class="link">=</span> t<span class="link">,</span> n<span class="link">,</span> k<span class="link">,</span> m<span class="link">,</span> ch<span class="link">,</span> l<span class="link">,</span> ꞌ<span class="link">,</span> s<span class="link">,</span> r<span class="link">,</span> d<span class="link">,</span> h<span class="link">,</span> w<span class="link">,</span> b<span class="link">,</span> y<span class="link">,</span> p<span class="link">,</span> g
<span class="catkey">F</span> <span class="link">=</span> n<span class="link">,</span> l<span class="link">,</span> ꞌ<span class="link">,</span> t<span class="link">,</span> k<span class="link">,</span> r<span class="link">,</span> p
<span class="catkey">V</span> <span class="link">=</span> a<span class="link">,</span> i<span class="link">,</span> e<span class="link">,</span> u<span class="link">,</span> o</div>
      <p>This creates three groups of graphemes. <code class="example">C</code> is the group of all consonants, <code class="example">V</code> is the group of all vowels, and <code class="example">F</code> is the group of some of the consonants that will be used syllable finally.</p>
      <p>These graphemes are separated by commas, however an alternative is to use spaces: <code class="example">C = t n k m ch l ꞌ s r d h w b y p g</code>.</p>

      <p>By default, the graphemes' frequencies decrease as they go to the right, according to the Gusein-Zade distribution. <a href="#vocDistributions">You can change this distribution</a>. In the above example, when Vocabug needs to choose a <code class="example">V</code>, it will choose <code class="example">a</code> the most at 43%, <code class="example">i</code> the second-most at 26%, <code class="example">e</code> the third-most at 17%, <code class="example">u</code> the fourth-most at 10%, and <code class="example">o</code> the fifth most at 4%.</p>
      
      <p>Need more than 26 categories? Vocabug supports the following additional characters as the key of a category or <a href="#vocSegments">segment</a>: <code class="example">Á Ć É Ǵ Í Ḱ Ĺ Ḿ Ń Ó Ṕ Ŕ Ś Ú Ẃ Ý Ź À È Ì Ǹ Ò Ù Ẁ Ỳ Ǎ Č Ď Ě Ǧ Ȟ Ǐ Ǩ Ľ Ň Ǒ Ř Š Ť Ǔ Ž Ä Ë Ḧ Ï Ö Ü Ẅ Ẍ Ÿ Γ Δ Θ Λ Ξ Π Σ Φ Ψ Ω</code></p>
        
      <h3 id="vocCategoryinCategory"><a class="head-num">5.1</a>Categories inside categories and set-categories</h3>
      <p>You can use categories inside categories, as long as the referenced category has previously been defined. For example:</p>
      <div class="prog-pre"><span class="directive">category-distribution</span><span class="link">:</span> <span class="directive">flat</span>
<span class="catkey">L</span> <span class="link">=</span> aa<span class="link">,</span> ii<span class="link">,</span> ee<span class="link">,</span> oo
<span class="catkey">V</span> <span class="link">=</span> a<span class="link">,</span> i<span class="link">,</span> e<span class="link">,</span> o<span class="link">,</span> <span class="catkey">L</span></div>
      <p>In the example above, <code class="example">V</code> has a 20% chance of being a long vowel.</p>
      <p>You can also enclose a set of graphemes in curly braces <code class="example">{</code> and <code class="example">}</code>. This is called a 'set-category'. This set will be treated as if it were a reference to a category in terms of frequency. For example, we could write the same example as this:</p>
      <div class="prog-pre"><span class="directive">category-distribution</span><span class="link">:</span> <span class="directive">flat</span><br><span class="catkey">V</span> <span class="link">=</span> a<span class="link">,</span> i<span class="link">,</span> e<span class="link">,</span> o<span class="link">,</span> <span class="cm-matchingBracket"><span class="regexp">{</span></span>aa<span class="link">,</span> ii<span class="link">,</span> ee<span class="link">,</span> oo<span class="cm-matchingBracket"><span class="regexp">}</span></span></div>
      <p>Assigning weights to categories in categories and set-categories is possible.</p>
      <p>Categories inside categories and set-categories CANNOT be a part of any sequence. for example <code class="example">C = Xz</code> or <code class="example">C = x{c, d}</code> or <code class="example">C = {a, b}{c, d}</code> will not give the results you might want. To get sequence-like behaviour like that, you will need to use <a href="#vocSegments">segments</a>.</p>

      <h2 id="vocBuildingWords"><a class="head-num">6</a>Building words</h2>

      <h3 id="vocWords"><a class="head-num">6.1</a>Words</h3>
      <p>The <code class="example">words:</code> directive defines a set of 'word-shapes' that Vocabug will choose from to create words. A word-shape can consist of individual graphemes, <a href="#vocCategories">categories</a>, <a href="#vocSegments">segments</a> or a mixture of both.</p>
      <p>By default, words are selected using the Zipf distribution. The first word-shape will be chosen the most often, then the second word-shape the second most often and so on. <a href="#vocDistributions">You can change this distribution</a>. Below is a very simple example that will generate words with one to three CV syllables:</p>
      <div class="prog-pre"><span class="catkey">C</span> <code class="link">=</code> t<code class="link">,</code> n<code class="link">,</code> k<code class="link">,</code> m<code class="link">,</code> l<code class="link">,</code> s<code class="link">,</code> r<code class="link">,</code> d<code class="link">,</code> h<code class="link">,</code> w<code class="link">,</code> b<code class="link">,</code> j<code class="link">,</code> p<code class="link">,</code> g
<span class="catkey">V</span> <code class="link">=</code> a<code class="link">,</code> i<code class="link">,</code> o<code class="link">,</code> e<code class="link">,</code> u
<span class="directive">words</span><span class="link">:</span> <span class="catkey">CV</span><code class="link">,</code> <span class="catkey">CVCV</span><code class="link">,</code> <span class="catkey">CVCVCV</span><span class="link">,</span> <span class="catkey">V</span></div>

        <p>Word-shapes may alternatively be declared in the <code class="example">BEGIN words:</code> block. Allowing word-shapes to be declared over multiple lines, and allowing the use of comments between word-shapes:</p>
      <div class="prog-pre"><span class="directive">BEGIN words</span><span class="link">: </span><span class="catkey">CV</span><code class="link">,</code><br>  <span class="catkey">CVCV</span><code class="link">,</code> <span class="catkey">CVCVCV</span><code class="link">,</code>
<span class="comment">; This is a comment</span><br>  <span class="catkey">V</span><br><span class="directive">END</span></div>
        <p>You must use the <code class="example">END</code> keyword on a new line to end the block.</p>

      <h3 id="vocSegments"><a class="head-num">6.2</a>Segments</h3>
      <p>Segments are a system that provides an abbreviation of parts of a <a href="#vocWords">word-shape</a>. Typically you would use it to define the shape of a syllable. Segments are defined similarly to categories, but with several important differences:</p>
      <ul class="paragraphian">
        <li>Every segment's key starts with <code class="example">$</code>. <code class="example">S = s</code> is a <a href="#vocCategories">category</a>; <code class="example">$S = s</code> is a segment.</li>
        <li>Segments are not sets like categories are. <code class="example">$M = a, b, c</code> will not work as you might expect (because as already stated, segments are abbreviation for word-shapes). You would need to use a <a href="#vocPickOne">pick-one-set</a>, i.e: <code class="example">$M = {a, b, c}</code></li>
      </ul>
      <p>For example you could write the last example like so:</p>
      <div class="prog-pre"><span class="catkey">C</span> <code class="link">=</code> t<code class="link">,</code> n<code class="link">,</code> k<code class="link">,</code> m<code class="link">,</code> l<code class="link">,</code> s<code class="link">,</code> r<code class="link">,</code> d<code class="link">,</code> h<code class="link">,</code> w<code class="link">,</code> b<code class="link">,</code> j<code class="link">,</code> p<code class="link">,</code> g
<span class="catkey">V</span> <code class="link">=</code> a<code class="link">,</code> i<code class="link">,</code> o<code class="link">,</code> e<code class="link">,</code> u<br><span class="catkey">$S</span> <span class="link">=</span> <span class="catkey">CV</span>
<span class="directive">words</span><span class="link">:</span> <span class="catkey">$S $S$S $S$S$S</span></div>
      <p>You can put segments inside segments.</p>

      <h3 id="vocPickOne"><a class="head-num">6.3</a>Pick-one-set</h3>
      <p>A pick-one-set is a group of graphemes and categories separated by spaces or commas, enclosed in curly braces <code class="example">{</code> and <code class="example">}</code>. Vocabug will pick an option from that pick-one just like it would from a segment. For example:</p>
      <div class="prog-pre"><span class="catkey">V</span> <span class="link">=</span> a<span class="link">,</span> u
<span class="directive">words</span><span class="link">:</span> t<span class="regexp">{</span><span class="catkey">V</span><span class="link">,</span> x<span class="regexp">}</span></div>
      <p>This will produce either <code class="example">ta</code>, <code class="example">tu</code> or <code class="example">tx</code>.</p>
      <p>Pick-one-sets can be nested inside each other.</p>
      <p>Anything inside the pick-one can be assigned a weight, and a pick-one itself can be assigned a weight as well if it is nested inside another set:</p>
      <div class="prog-pre"><span class="directive">words</span><span class="link">:</span> <code class="regexp">{</code>a<code class="weight">*1</code><span class="link">,</span> b<code class="weight">*2</code><span class="link">,</span> <code class="regexp">{</code>c<span class="link">,</span> d<code class="regexp">}</code><code class="weight">*2</code><code class="regexp">}</code></div>

      <h3 id="vocOptional"><a class="head-num">6.4</a>Optional-set</h3>
      <p>Using round brackets, <code class="example">(</code> and <code class="example">)</code>, optional-set works the same way as <a href="#vocPickOne">pick-one-set</a>, the only difference is that what's inside them can either appear in the word or not. The probability of each of these variants is 10% by default.</p>
      <div class="prog-pre"><span class="directive">words</span><span class="link">:</span> ta<span class="regexp">(</span>n<span class="link">,</span> t<span class="link">,</span> l<span class="regexp">)</span></div>
      <p>In the above example, there is a 10% chance of getting one of <code class="example">tan</code>, <code class="example">tat</code> or <code class="example">tal</code>, but a 90% chance of <code class="example">ta</code>.</p>

      <h4 id="vocOptionalsWeight"><a class="head-num">6.4.1</a>Optionals weight</h4>
      <p>By default, an optional-set has a 10% chance of being included in the word. You can change this probability with the <code class="example">optionals-weight:</code> directive.</p>

      <h3 id="vocSupraSet"><a class="head-num">6.5</a>Supra-set</h3>
      <p>A 'supra-set', is applied over the entire word, and there can only be one supra set. less than and greater sign <code class="example">&lt;</code> and <code class="example">&gt;</code>, denotes each item in the supra-set and their location in the word. The items of a supra-set can only be a category, or the null grapheme <code class="example">^</code>. Only one item in the supra-set will be picked for that generated word.</p>
      <p>Supra-set is a feature designed to help generate words with stress systems, pitch accent systems, or other word-based suprasegmentals. Here is an example where it is used for a stress system:</p>
      <div class="prog-pre"><span class="catkey">C</span> <span class="link">=</span> t<br><span class="catkey">V</span> <span class="link">=</span> a<br><span class="catkey">X</span> <span class="link">=</span> '<br><span class="directive">words</span><span class="link">:</span> <span class="regexp">(&lt;</span><span class="catkey">X</span><span class="regexp">&gt;</span><span class="catkey">C</span><span class="catkey">V</span><span class="regexp">)&lt;</span><span class="catkey">X</span><span class="regexp">&gt;</span><span class="catkey">CV</span></div>
      <p>This produces any of the following words: <code class="example">'ta</code>, <code class="example">ta'ta</code>, <code class="example">'tata</code>, never any words with more than one <code class="example">'</code>. Notice here that <code class="example">ta</code> is not possible -- A supra-set item is only chosen after dealing with any sets that the supra-set items are nested in.</p>
      <p>See the "Romance-like" example for a language that uses supra-set for its stress system.</p>
      
      <h4 id="vocSupraSetWeight"><a class="head-num">6.5.1</a>Supra-set weight</h4> 
      <p>You can set the weights of supra-set items like so:</p>
      <div class="prog-pre"><span class="catkey">R</span> <span class="link">=</span> r<br><span class="catkey">$X</span> <span class="link">=</span> o<span class="regexp">&lt;</span><span class="catkey">R</span><span class="weight">*8</span><span class="regexp">&gt;</span><br><span class="catkey">$Y</span> <span class="link">=</span> e<span class="regexp">&lt;</span><span class="catkey">R</span><span class="weight">*2</span><span class="regexp">&gt;</span><br><span class="directive">words</span><span class="link">:</span> <span class="catkey">$X$Y</span></div>
      <p>The above example has an 80% chance of generating <code class="example">ore</code> and a 20% chance of generating <code class="example">oer</code>.</p>
      <p>Supra-set item weights support a sentinel value -- a 'super-heavy' value <code class="example">s</code>. This <code class="example">s</code> will ensure the supra-set item attached to this weight is always chosen over others. For example: <code class="example">&lt;V*s&gt;</code></p>

      <h2 id="vocDistributions"><a class="head-num">7</a>Default distributions</h2>
      <p><b>The ordering of items matters</b> in <a href="#vocCategories">categories</a>, <a href="#vocSegments">segments</a> and <a href="#vocWords">word-shapes</a>. The first item will be chosen the most often, the second grapheme the second most often, and so on.</p>
      <p>You can change these default distributions (another name for this might be "default drop-off", but I digress). For categories, the default is <code class="example">gusein-zade</code> and you change it with the <code class="example">category-distribution:</code> directive. For the separate setting for word-shapes, the default is <code class="example">zipfian</code> and you change it with the <code class="example">wordshape-distribution:</code> directive. The distribution will be applied to each item in a set, and then recursively to any set that set is nested in (treating the nested set as an item), then applied at the surface level.</p>

      <ul class="paragraphian">
        <li>A <code class="example">zipfian</code> distribution approximates natural language frequency for words, where the highest-ranked item receives the greatest weight, and subsequent ones decay steeply until flattening out.</li>
        <li>A <code class="example">gusein-zade</code> distribution offers a gentler slope that is natural across phonemes in a language, following a logarithmic decay that still prioritizes top-ranked items but spreads weight more evenly</li>
        <li><code class="example">Shallow</code> distribution, the red-headed step-child of the distributions. It doesn't occur in natural linguistics, but offers us something between Flat and Gusein-Zade. It is Zipfian in nature, a 'long-tailed Zipfian distribution'</li>
        <li>A <code class="example">flat</code> distribution treats all items equally. This is not to say the items will be evenly chosen -- items are still being randomly chosen on a generation, they just have the same weight</li>
      </ul>

      <img src="img/distribution.png" alt="Distribution graph" style="width: 100%;">

      <h2 id="vocAssigningWeights"><a class="head-num">8</a>Assigning weights</h2>
      <p>If you want to set your own frequency for graphemes in a <a href="#vocCategories">category</a> or category-set, items in a <a href="#vocPickOne">pick-one-set</a>, or <a href="#vocOptional">optional-set</a>, or <a href="#vocWords">word-shapes</a> in the <code class="example">words:</code> directive, you can use an asterisk <code class="example">*</code> to specify the weight for each item, like so:</p>
      <div class="prog-pre"><span class="catkey">V</span> <span class="link">=</span> a<span class="weight">*5</span><span class="link">,</span> e<span class="weight">*4</span><span class="link">,</span> i<span class="weight">*3</span><span class="link">,</span> o<span class="weight">*2</span><span class="link">,</span> u<span class="weight">*1</span>
<span class="catkey">$S</span> <span class="link">=</span> <span class="regexp">{</span><span class="catkey">V</span><span class="weight">*8</span><span class="link">,</span> x<span class="weight">*2</span><span class="regexp">}</span>
<span class="directive">words</span><span class="link">:</span> <span class="catkey">$S</span><span class="weight">*2</span> y</div>
      <p><code class="example">V</code> has approximately the following probabilities: a: 33%, e: 27%, i: 20%, o: 13%, u: 7%. The <a href="#vocPickOne">pick-one-set</a> in the <code class="example">$S</code> segment has an 80% chance of producing a V category over the x grapheme. And the first word-shape in the <code class="example">words:</code> directive has twice the chance of being chosen over the next word-shape.</p>
      <p>As you might have noticed in the example above, in a sequence that has at least one weighted option, it overwrites any default distributions. Also important to note is that any other option that you had not given a weight (inside that set, or on the surface level), is given a weight of 1.</p>

      <h2 id="vocAlphabetisation"><a class="head-num">9</a>Alphabetisation</h2>
      <p>The alphabet directive gives Vocabug a custom alphabetisation order for words, when the sort words checkbox is selected.</p>
      <div class="prog-pre"><span class="directive">alphabet</span><span class="link">:</span> a<span class="link">,</span> b<span class="link">,</span> c<span class="link">,</span> e<span class="link">,</span> f<span class="link">,</span> h<span class="link">,</span> i<span class="link">,</span> k<span class="link">,</span> l<span class="link">,</span> m<span class="link">,</span> n<span class="link">,</span> o<span class="link">,</span> p<span class="link">,</span> p'<span class="link">,</span> r<span class="link">,</span> s<span class="link">,</span> t<span class="link">,</span> t'<span class="link">,</span> y</div>

      <p>This would order generated words like so: <code class="example">cat</code>, <code class="example">chat</code>, <code class="example">cumin</code>, <code class="example">frog</code>, <code class="example">tray</code>, <code class="example">t'a</code>, <code class="example">yanny</code></p>

      <h3 id="vocInvisibility"><a class="head-num">9.1</a>Invisibility</h3>
      <p>Sometimes you will want characters, such as syllable dividers, to be invisible to alphabetisation. You can do this by listing these characters in the invisible: directive.</p>
      <div class="prog-pre"><span class="directive">invisible</span><span class="link">:</span> .<span class="link">,</span> ˈ<br></div>
      <p> This will make these generated words: <code class="example">za'ta</code>, <code class="example">'ba.ta</code>, <code class="example">'za.ta</code> be reorderd into: <code class="example">'ba.ta</code>, <code class="example">za'ta</code>, <code class="example">'za.ta</code></p>

      <h2 id="vocGraphemes"><a class="head-num">10</a>Defining graphemes</h2>
      <p>The <code class="example">graphemes:</code> directive tells Vocabug which (multi)graphs, including character + combining diacritics, are to be treated as grapheme units when using <a href="#nescaTransform">transformations</a>.</p>
      <div class="prog-pre"><span class="directive">graphemes</span><span class="link">:</span> a<span class="link">,</span> b<span class="link">,</span> c<span class="link">,</span> ch<span class="link">,</span> e<span class="link">,</span> f<span class="link">,</span> h<span class="link">,</span> i<span class="link">,</span> k<span class="link">,</span> l<span class="link">,</span> m<span class="link">,</span> n<span class="link">,</span> o<span class="link">,</span> p<span class="link">,</span> p'<span class="link">,</span> r<span class="link">,</span> s<span class="link">,</span> t<span class="link">,</span> t'<span class="link">,</span> y</div>
      <p>In the above example, we defined <code class="example">ch</code> as a grapheme. This would stop a rule such as <code class="example">c -> g</code> changing the word <code class="example">chat</code> into <code class="example">ghat</code>, but it will make <code class="example">cobra</code> change into <code class="example">gobra</code>.</p>

      <p>'But the order of letters stated in my <code class="example">alphabet:</code> directive is the same as my graphemes in my <code class="example">graphemes:</code> directive, do I have to list them twice?' You might ask. You can list both using the <code class="example">alphabet-and-graphemes:</code> directive.</p>

      <p>Graphemes may alternatively be declared in the <code class="example">BEGIN graphemes:</code> block. Allowing graphemes to be declared over multiple lines, and allowing the use of comments between graphemes. You must use the <code class="example">END</code> keyword on a new line to end the block.</p>

      <h2 id="nescaTransform"><a class="head-num">11</a>Transform</h2>
      <p>Once words are generated, you might want to modify them to prevent certain sequences, outright reject certain words, or simulate historical sound changes. This is the purpose of the transform block, which implements the <a href="./nesca.html">NeSCA program</a>.</p>
      <p>All transforms must be used inside this block. To terminate this block you use an <code class="example">END</code> line. However, all unterminated blocks are automatically terminated at the end of the definition-build:</p>
      <div class="prog-pre"><span class="directive">BEGIN transform</span><span class="link">:</span><br><span class="comment">; Your rules go here</span><br><span class="directive">END</span></div>
      <p>A rule can be summarised in four fields: <code class="example">CHANGE / CONDITION ! EXCEPTION</code>. The characters <code class="example">/</code> and <code class="example">!</code> that precede each field (except for the <code class="example">CHANGE</code>) are necessary for signalling each field. For example, including a <code class="example">!</code> will signal that this rule contains an exception, and all text following it until the next field marker will be interpreted as such.</p>

      <p>Every rule begins on a new line and must contain a <code class="example">CHANGE</code>. The <code class="example">CONDITION</code> or <code class="example">EXCEPTION</code> fields are optional.</p>
      <p>If you want to capture graphemes that are normally syntax characters in transforms, you will need to <a href="#vocEscapeTransform">escape them</a>.</p>

      <p>When this document uses examples to explain transformations, the last comment shows an example word transforming. For example <code class="example">; amda ==> ampa</code> means the rule will transform the word <code class="example">amda</code> into <code class="example">ampa</code></p>

      <h2 id="nescaTheChange"><a class="head-num">12</a>The change</h2>
      <p>The format of the change can be expressed as <code class="example">TARGET -> RESULT</code>.</p>
      <ul class="paragraphian">
        <li><code class="example">TARGET</code> specifies which part of the word is being changed</li>
        <li>Then followed by a space and the <code class="example">></code> character. <code class="example">></code> can be swapped with either <code class="example">-></code>, <code class="example">=></code>, <code class="example">⇒</code> or <code class="example">→</code> if you prefer</li>
        <li><code class="example">RESULT</code> is what <code class="example">TARGET</code> is changing into, or in other words, replacing</li>
      </ul>
      <p>Let's look at a simple unconditional rule:</p>
      <div class="prog-pre"><span class="comment">; Replace every [o] with [x]</span><br>  o <span class="link">-></span> x<br><span class="comment">; bodido ==> bxdidx</span></div>
      <p>In this rule, we see every instance of <code class="example">o</code> become <code class="example">x</code>.</p>

      <h3 id="nescaConcurrentChange"><a class="head-num">12.1</a>Concurrent change</h3>
      <p>Concurrent change is achieved by listing multiple graphemes in <code class="example">TARGET</code> separated by commas, and listing the same amount of resultant graphemes in <code class="example">RESULT</code> separated by commas. Changes in a concurrent change execute at the same time:</p>
      <div class="prog-pre"><span class="comment">; Switch [o] and [a] around</span><br>  o<span class="link">,</span> a <span class="link">-></span> a<span class="link">,</span> o<br><span class="comment">; boda ==> bado</span></div>
      <p>Notice that the above example is different to the example below:</p>
      <div class="prog-pre">  o <span class="link">-></span> a<br>  a <span class="link">-></span> o<br><span class="comment">; boda ==> bodo</span></div>
      <p>where each change is on its own line. We can see <code class="example">o</code> merge with <code class="example">a</code>, then <code class="example">a</code> becomes <code class="example">o</code>.</p>

      <h3 id="nescaMergingChange"><a class="head-num">12.2</a>Merging change</h3>
      <p>Instead of listing each <code class="example">RESULT</code> in a concurrent change, we can instead list just one that all the <code class="example">TARGET</code>s will merge into:</p>
      <div class="prog-pre"><span class="comment">; Merge [o] and [a] into [x]</span><br>  o<span class="link">,</span> a <span class="link">-></span> x<br><span class="comment">; boda ==> bxdx</span></div>
      <p>This is equivalent to:</p>
      <div class="prog-pre"><span class="comment">; Merge [o] and [a] into [x]</span><br>  o<span class="link">,</span> a <span class="link">-></span> x<span class="link">,</span> x<br><span class="comment">; boda ==> bxdx</span></div>

      <h3 id="nescaReject"><a class="head-num">12.3</a>Reject</h3>
      <p>To remove, or in other words, reject a word, you use the <code class="example">^REJECT</code> keyword in <code class="example">RESULT</code>:</p>
      <div class="prog-pre">a<span class="link">,</span> bi <span class="link">-></span> <span class="operator">^REJECT</span></div>
      <p>In the above example, any word that contains <code class="example">a</code> or <code class="example">bi</code> will be rejected.</p>
      <p>A shorthand version to <code class="example">^REJECT</code> is <code class="example">^R</code></p>

      <h2 id="nescaInsertionAndDeletion"><a class="head-num">13</a>Insertion and deletion</h2>
      <p>Insertion requires a <a href="#nescaTheCondition">condition</a> to be present, and for a caret <code class="example">^</code> to be present in <code class="example">TARGET</code>, representing nothing.</p>
      <div class="prog-pre"><span class="comment">; Insert [a] in between [b] and [t]</span>
  <span class="operator">^</span> <span class="link">-></span> a <span class="link">/</span> b<span class="link">_</span>t
<span class="comment">; bt ==> bat</span></div>
      <p>Deletion happens when <code class="example">^</code> is present in <code class="example">RESULT</code>:</p>
      <div class="prog-pre"><span class="comment">; Delete every [b]</span>
  b <span class="link">-></span> <span class="operator">^</span>
<span class="comment">; bubda ==> uda</span></div>

      <h2 id="nescaTheCondition"><a class="head-num">14</a>The condition</h2>
      <p>Conditions follow <a href="#nescaTheChange">the change</a> and are placed after a forward slash. When a transform has a condition, the target must meet the environment described in the condition to execute.</p>
      <p>The format of a condition is <code class="example">/ BEFORE_AFTER</code></p>
      <ul class="paragraphian">
        <li>A forward slash <code class="example">/</code> begins a condition</li>
        <li><code class="example">BEFORE</code> is anything in the word before the target</li>
        <li>The underscore <code class="example">_</code> is a reference to the target in a condition</li>
        <li><code class="example">AFTER</code> is anything in the word after the target</li>
      </ul>
      <p>For example:</p>
      <div class="prog-pre"><span class="comment">; Change [o] into [x] only when it is between [p]s</span><br>  o <span class="link">-></span> x <span class="link">/</span> p<span class="link">_</span>p<br><span class="comment">; opoptot ==> opxptot</span></div>

      <h3 id="nescaMultipleCondition"><a class="head-num">14.1</a>Multiple conditions in one rule</h3>
      <p>Multiple conditions for a single rule can be made by separating each condition with additional forward slashes. The change will happen if it meets either, or both of the conditions:</p>
      <div class="prog-pre"><span class="comment">; Change [o] into [x] only when it is between [p]s or [t]s</span><br>  o <span class="link">-></span> x <span class="link">/</span> p<span class="link">_</span>p <span class="link">/</span> t<span class="link">_</span>t<br><span class="comment">; opoptot ==> opxptxt</span></div>
      
      <h3 id="nescaWordBoundary"><a class="head-num">14.2</a>Word boundary</h3>
      <p>Hash <code class="example">#</code> matches to word boundaries. Either the beginning of the word if it is in <code class="example">TARGET</code>, or the end of the word if it is in <code class="example">RESULT</code></p>
      <div class="prog-pre">  o <span class="link">-></span> x <span class="link">/</span> p<span class="link">_</span>p<span class="regexp">#</span><br><span class="comment">; opoppop ==> opoppxp</span></div>

      <h3 id="nescaChanceCondition"><a class="head-num">14.3</a>The chance condition</h3>
      <p>The chance condition is placed following a <code class="example">?</code> as a number from 0 to 100. This number represents the chance of the transformation occuring:</p>
      <div class="prog-pre">aa <span class="link">-></span> a <span class="link">?</span> 30</div>
      <p>In the above example, the transformation will execute only 30% of the time.</p>

      <h2 id="nescaTheException"><a class="head-num">15</a>The exception</h2>
      <p>Exceptions are placed following an exclamation mark <code class="example">!</code> and go after the condition, if there is one. Exceptions function exactly like the opposite of the condition -- when a transform has an exception, the target must meet the environment described in the exception to prevent execution:</p>
      <div class="prog-pre">aa <span class="link">-></span> a <span class="link">!</span> <span class="link">_</span><span class="regexp">#</span></div>
      <p>In the above example, the transformation will not execute if <code class="example">aa</code> is at the end of the word.</p>
      <p>An alternative to using an exclamation mark is to use two forward slashes <code class="example">//</code>.</p>

      <h2 id="nescaUsingCategories"><a class="head-num">16</a>Using categories</h2>
      <p>You can reference categories in transforms. The category will behave in the same way as an alternator set:</p>
      <div class="prog-pre">  <span class="catkey">B</span> <span class="link">=</span> x<span class="link">,</span> y<span class="link">,</span> z<br><span class="directive">BEGIN transform</span><span class="link">:</span><br>  <span class="catkey">B</span> <span class="link">-></span> <span class="operator">^</span><br><code class="comment">; xapay ==> apa</code></div>

      <p>If the category is part of a target, it MUST be inside an alternator set:</p>
      <div class="prog-pre">  <span class="catkey">B</span> <span class="link">=</span> x<span class="link">,</span> y<span class="link">,</span> z<br><span class="directive">BEGIN transform</span><span class="link">:</span><br>  <span class="regexp">{</span><span class="catkey">B</span><span class="regexp">}</span>v <span class="link">-></span> <span class="operator">^</span><br><code class="comment">; xvapay ==> apay</code></div>

      <h2 id="nescaFeatures"><a class="head-num">17</a>Features</h2>
      <p>Let's say you had the grapheme, or rather, phoneme /i/ and wanted to capture it by its distinctive vowel features, <code class="example">+high</code> and <code class="example">+front</code>, and turn it into a phoneme marked with <code class="example">+high</code> and <code class="example">+back</code> features, perhaps /ɯ/. Features let you do this.</p>
      <p>The key of all features must consist of lowercase letters a to z, uppercase letters a to z, <code class="example">.</code>, <code class="example">-</code> or <code class="example">+</code></p>

      <h3 id="nescaProFeature"><a class="head-num">17.1</a>Pro-feature</h3>
      <p>A feature prepended with a plus sign <code class="example">+</code> is a 'pro-feature'. For example <code class="example">+voice</code>. We can define a set of graphemes that are marked by this feature by using this pro-feature. For example:</p>
      <div class="prog-pre"><span class="catkey">+voice</span> <span class="link">=</span> b<span class="link">,</span> d<span class="link">,</span> g<span class="link">,</span> v<span class="link">,</span> z</div>

      <h3 id="nescaAntiFeature"><a class="head-num">17.2</a>Anti-feature</h3>
      <p>A feature prepended with a minus sign <code class="example">-</code> is an 'anti-feature'. For example <code class="example">-voice</code>. We can define a set of graphemes that are marked by a lack of this feature by using this anti-feature. For example:</p>
      <div class="prog-pre"><span class="catkey">-voice</span> <span class="link">=</span> p<span class="link">,</span> t<span class="link">,</span> k<span class="link">,</span> f<span class="link">,</span> s</div>

      <h3 id="nescaParaFeature"><a class="head-num">17.3</a>Para-feature</h3>
      <p>A feature prepended with a greater-than-sign <code class="example">&gt;</code> is a 'para-feature'. A para-feature is simply a pro-feature where the graphemes marked as the anti-feature of this feature are the graphemes in the <code class="example">graphemes:</code> directive that are not not marked by this para-feature:</p>
      <div class="prog-pre"><span class="directive">graphemes</span><span class="link">:</span> a<span class="link">,</span> b<span class="link">,</span> h<span class="link">,</span> i<span class="link">,</span> k<span class="link">,</span> n<span class="link">,</span> o<span class="link">,</span> t<br><span class="catkey">&gt;voice</span> <span class="link">=</span> a<span class="link">,</span> i<span class="link">,</span> o</div>
      <p>Is equivalent to the below example:</p>
      <div class="prog-pre"><span class="catkey">+vowel</span> <span class="link">=</span> a<span class="link">,</span> i<span class="link">,</span> o<br><span class="catkey">-vowel</span> <span class="link">=</span> b<span class="link">,</span> h<span class="link">,</span> k<span class="link">,</span> n<span class="link">,</span> t</div>

      <p>'Where does this leave graphemes that are not marked by either the pro-feature or the anti-feature of a feature?', you might ask. Such graphemes are <em>unmarked</em> by that feature.</p>

      <h3 id="nescaFeatureInFeature"><a class="head-num">17.4</a>Referencing features inside features</h3>

      <p>Features can be referenced inside features. For example:</p>
      <div class="prog-pre"><span class="catkey">+vowel</span> <span class="link">=</span> a<span class="link">,</span> i<span class="link">,</span> o<br><span class="catkey">+non-yod</span> <span class="link">=</span> <span class="catkey">+vowel</span><span class="link">,</span> <span class="operator">^</span>i</div>

      <p>Use a caret in front of a grapheme to ensure that that grapheme is not part of the pro/anti/para-feature. In the example above, the pro-feature '<code class="example">+non-yod</code>' is composed of the graphemes <code class="example">a</code> and <code class="example">o</code> -- the grapheme <code class="example">i</code> is not part of this pro-feature. Due to the recursive nature of nested features, this removed grapheme will be removed... aggressively. For example, If <code class="example">+non-yod</code> were to be referenced in a different feature, that feature would always not have <code class="example">i</code> as a grapheme.</p>



      <h3 id="nescaUsingFeatures"><a class="head-num">17.5</a>Using Features</h3>

      <p>To capture graphemes that are marked by features in a transform, the features must be listed in a 'feature-matrix' surrounded by <code class="example">[</code> and <code class="example">]</code>. The graphemes in a word must be marked by each pro-/anti-feature in the feature-matrix to be captured. For example if a feature-matrix <code class="example">[+high, +back]</code> captures the graphemes: <code class="example">u, ɯ</code>, another feature-matrix <code class="example">[+high, +back, -round]</code> would capture <code class="example">ɯ</code> only.</p>
      <p>The very simple example below is written to change all voiceless graphemes that have a voiced counterpart into their voiced counterparts:</p>

      <div class="prog-pre"><span class="catkey">-voice</span> <span class="link">=</span> p<span class="link">,</span> t<span class="link">,</span> k<span class="link">,</span> f<span class="link">,</span> s
<span class="catkey">+voice</span> <span class="link">=</span> b<span class="link">,</span> d<span class="link">,</span> g<span class="link">,</span> v<span class="link">,</span> z

<span class="directive">BEGIN transform</span><span class="link">:</span>
  <span class="catkey">[-voice]</span> <span class="link">-&gt;</span> <span class="catkey">[+voice]</span>
<span class="comment">; tamefa ==&gt; dameva</span>
<span class="directive">END</span></div>

      <p>In this rule, in <code class="example">RESULT</code>, <code class="example">[+voice]</code> has a symmetrical one-to-one change of graphemes from the graphemes in <code class="example">[-voice]</code> in <code class="example">TARGET</code>, leading to a concurrent change. Let's quickly imagine a scenario where the only <code class="example">[+voice]</code> grapheme was <code class="example">b</code>. The result will be a merging of all <code class="example">-voice</code> graphemes into <code class="example">b</code>: <code class="example">tamepfa ==&gt; bamebba</code>.</p>

      <h3 id="nescaFeatureField"><a class="head-num">17.6</a>Feature-field</h3>
      <p>Feature-fields allow graphemes to be easily marked by multiple features in table format.</p>
      <p>The feature-field begins with a <code class="example">+-</code> and a space. The graphemes being marked by the features are listed on the first row. The features are listed in the first column.</p>
      <p>For example:</p>
      <div class="prog-pre"><code class='directive'>+-</code>         m n p b t d k g s h l j
voice      <code class='operator'>+</code> <code class='operator'>+</code> <code class='regexp'>-</code> <code class='operator'>+</code> <code class='regexp'>-</code> <code class='operator'>+</code> <code class='regexp'>-</code> <code class='operator'>+</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='operator'>+</code> <code class='operator'>+</code>
plosive    <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='operator'>+</code> <code class='operator'>+</code> <code class='operator'>+</code> <code class='operator'>+</code> <code class='operator'>+</code> <code class='operator'>+</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code>
nasal      <code class='operator'>+</code> <code class='operator'>+</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code>
fricative  <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='operator'>+</code> <code class='operator'>+</code> <code class='regexp'>-</code> <code class='regexp'>-</code>
approx     <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='operator'>+</code> <code class='operator'>+</code>
labial     <code class='operator'>+</code> <code class='regexp'>-</code> <code class='operator'>+</code> <code class='operator'>+</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code>
alveolar   <code class='regexp'>-</code> <code class='operator'>+</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='operator'>+</code> <code class='operator'>+</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='operator'>+</code> <code class='regexp'>-</code> <code class='operator'>+</code> <code class='regexp'>-</code>
palatal    <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='operator'>+</code>
velar      <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='operator'>+</code> <code class='operator'>+</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code>
glottal    <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='operator'>+</code> <code class='regexp'>-</code> <code class='regexp'>-</code>

<code class='directive'>+-</code>     a e i o
high   <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='operator'>+</code> <code class='regexp'>-</code>
mid    <code class='regexp'>-</code> <code class='operator'>+</code> <code class='regexp'>-</code> <code class='operator'>+</code>
low    <code class='operator'>+</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code>
front  <code class='regexp'>-</code> <code class='operator'>+</code> <code class='operator'>+</code> <code class='regexp'>-</code>
back   <code class='operator'>+</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='operator'>+</code>
round  <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='operator'>+</code></div>
      <ul>
        <li>A <code class="example">+</code> means to mark the grapheme by that feature's pro-feature</li>
        <li>A <code class="example">-</code> means to mark the grapheme by that feature's anti-feature</li>
        <li>A <code class="example">.</code> means to leave the grapheme unmarked by that feature</li>
      </ul>
      <p>Here are some matrices of these features and which graphemes they would capture:</p>
      <ul>
        <li><code class="example">[+plosive]</code> captures the graphemes <code class="example">b, d, g, p, t, k</code></li>
        <li><code class="example">[+voiced, +plosive]</code> captures the graphemes <code class="example">b, d, g</code></li>
        <li><code class="example">[+voiced, +labial, +plosive]</code> captures the grapheme <code class="example">b</code></li>
      </ul>

      <h2 id="nescaAltAndOpt"><a class="head-num">18</a>Alternator and Optionalator</h2>
      <p>These cannot be nested.</p>

      <h3 id="nescaAlternatorSet"><a class="head-num">18.1</a>Alternator-set</h3>
      <p>Enclosed in curly braces, <code class="example">{</code> and <code class="example">}</code>, only one Item in an alternator set will be part of each sequence. For example:</p>
      <div class="prog-pre">  p<span class="regexp">{</span>w<span class="link">,</span> j<span class="regexp">}</span> <span class="link">-></span> pp</div>
      <p>The above example is equivalent to:</p>
      <div class="prog-pre">  pw<span class="link">,</span> pj <span class="link">-></span> pp</div>
      <p>These can also be used in exceptions and conditions.</p>

      <h3 id="nescaOptionalatorSet"><a class="head-num">18.2</a>Optionalator-set</h3>
      <p>Items in an optionalator, enclosed in <code class="example">(</code> and <code class="example">)</code> can be captured whether or not they appear as part of a grapheme or as part of a sequence of graphemes:</p>
      <div class="prog-pre"><span class="comment">; Merge [x] and [xw] into [k]</span><br>  x<span class="regexp">(</span>w<span class="regexp">)</span> <span class="link">-></span> k<br><span class="comment">; xwaxaħa ==> kakaħa</span></div>
      <p>Optional-set can also attach to an alternator-set:</p>
      <div class="prog-pre"><span class="comment">; Merge [x], [xw], [ħ] and [ħw] into [k]</span><br>  <span class="regexp">{</span>x<span class="link">,</span> ħ<span class="regexp">}</span><span class="regexp">(</span>w<span class="regexp">)</span> <span class="link">-></span> k<br><span class="comment">; xwaxaħa ==> kakaka</span></div>
      <p>Optionalator-set cannot be used on its own, it must be connected to other content.</p>

      <h2 id="nescaClusterfield"><a class="head-num">19</a>Cluster-field</h2>
      <p>Cluster-field is a way to target sequences of graphemes and change them. They are laid out as tables, and start with <code class="example">%</code> followed by a space. The first part of a sequence is in the first column, and the second part is in the first row. For example:</p>
      <div class="prog-pre"><span class="directive">%</span> p  t  k  m  n
m <span class="link">+</span>  nt nk <span class="link">+</span>  mm 
n mp <span class="link">+</span>  <span class="link">+</span>  nn <span class="link">+</span></div>

      <ul class="paragraphian">
        <li>In this example, <code class="example">np</code> becomes <i>mp</i> and <code class="example">mt</code> becomes <i>nt</i></li>
        <li><code class="example">+</code> means to not change the target cluster at all</li>
        <li>Cluster-fields can use <code class="example">^R</code> or <code class="example">^REJECT</code> to reject the word if it contains that sequence</li>
        <li>Cluster-fields can use <code class="example">^</code> or <code class="example">∅</code> to delete the target sequence</li>
        <li>These are executed concurrently just like concurrent changes. Their order does not matter</li>
        <li>Cluster-fields can also use conditions and exceptions, just put them on their own line</li>
      </ul>

      <h2 id="nescaWildcardsAndQuantifiers"><a class="head-num">20</a>Wildcards and quantifiers</h2>
      <p>Wildcards and the like in this section are special tokens that can represent arbitrary amounts of arbitrary graphemes, which is especially useful when you don't know precisely how many, or of what kind of grapheme there will be between two target graphemes in a word.</p>

      <h3 id="nescaQuantifier"><a class="head-num">20.1</a>Quantifier</h3>
      <p>Quantifier, using <code class="example">+</code>, will match once or as many times as possible to the grapheme to the left of it. Quantifier cannot be used in <code class="example">RESULT</code>:</p>
      <div class="prog-pre">  a<span class="regexp">+</span> <span class="link">-></span> o<br><code class="comment">; raraaaaa ==> roro</code></div>

      <h3 id="nescaBoundedQuantifier"><a class="head-num">20.2</a>Bounded quantifier</h3>
      <p>The bounded quantifier matches as many times its digit(s), enclosed in <code class="example">+[</code> and <code class="example">]</code>, to the things to the left.</p>
      <div class="prog-pre"><span class="comment">; Change [o] into [x] only when preceded by three [r]s</span><br>  o <span class="link">-></span> x <span class="link">/</span> r<span class="regexp">+[</span>3<span class="regexp">]</span><span class="link">_</span>
<code class="comment">; ororrro ==> ororrrx</code></div>

      <p>The digits in the quantifier can also be a range:</p>
      <div class="prog-pre"><span class="comment">; Change a sequence of 2 to 4 [o]s into [x]</span><br>  o<span class="regexp">+[</span>2<span class="link">,</span>4<span class="regexp">]</span> <span class="link">-></span> x
<code class="comment">; tootooooo ==> txtxo</code></div>


      <p>At the beginning of the list, <code class="example">,</code> represents all the possible numbers lower than the number to the right, not including zero.</p>
      <div class="prog-pre"><span class="comment">; Change a sequence of 1 to 4 [o]s into [x]</span><br>  o<span class="regexp">+[</span><span class="link">,</span>4<span class="regexp">]</span> <span class="link">-></span> x
<code class="comment">; tootooooo ==> txtx</code></div>

      <p>And finally at the end of the list, <code class="example">,</code> represents all possible numbers larger than the number to the the left</p>
        <div class="prog-pre"><span class="comment">; Change a sequence of 4 to as many as possible [o]s into [x]</span><br>  o<span class="regexp">+[</span>4<span class="regexp"><span class="link">,</span>]</span> <span class="link">-></span> x
<code class="comment">; toootooooo ==> toootx</code></div>

      <h3 id="nescaGeminateMark"><a class="head-num">20.3</a>Geminate-mark</h3>
      <p>Geminate-mark using colon <code class="example">:</code>, will match twice to the grapheme, or grapheme from a set or category, to the left of it. In other words, you can capture an item only when it is geminated using the geminate-mark:</p>
      <div class="prog-pre">  a<span class="regexp">:</span> <span class="link">-></span> o<br><code class="comment">; aaata => oata</code></div>

      <p>Unlike quantifier, a geminate mark can be used in <code class="example">RESULT</code>:</p>

      <div class="prog-pre">  a <span class="link">-></span> a<span class="regexp">:</span><br><code class="comment">; tat => taat</code></div>

      <h3 id="nescaKleeneStar"><a class="head-num">20.4</a>Kleene-star</h3>
      <p>Occasionally, you may want to match a grapheme whether it exists, there is one of it, or there is multiple of it consecutively, known as a "Kleene-star". There is <b>no</b> dedicated character for a Kleene star. Instead, you wrap the content followed by a quantifier, in an optionalator:</p>
      <div class="prog-pre">  u<span class="regexp">(</span>a<span class="regexp">+)</span> <span class="link">-></span> o<br><code class="comment">; ruaruaaaaa ==> roro</code></div>

      <h3 id="nescaWildcard"><a class="head-num">20.5</a>Wildcard</h3>
      <p>Wildcard, using asterisk <code class="example">*</code>, will match once to any grapheme. Wildcard does not match word boundaries. Wildcard cannot be used in <code class="example">RESULT</code>:</p>
      <div class="prog-pre"><code class="comment">; Any grapheme becomes [x] when any grapheme follows it</code><br>  <span class="regexp">*</span> <span class="link">-></span> x <span class="link">/</span> <span class="link">_</span><span class="regexp">*</span><br><code class="comment">; aomp ==> xxxp</code></div>
      <p>Wildcard can be placed by itself inside an <a href="#nescaOptionalatorSet">optionalator</a> <code class="example">(*)</code>, thereby allowing it to match nothing as well.</p>

      <h3 id="nescaAnythingsMark"><a class="head-num">20.6</a>Anythings-mark</h3>
      <p>The anythings-mark uses ampersand <code class="example">&</code> or the ellipsis character <code class="example">…</code> U+2026. It will match as many (but not zero) times to any grapheme as needed. For example:</p>
      <div class="prog-pre">  b<span class="regexp">&</span>t <span class="link">-></span> x<br><code class="comment">; babitto => xto</code></div>
      <p>As we can see, the rule matched <code class="example">b</code> followed by anything else until it reached the first <code class="example">t</code>, then stopped matching. Why did the anythings-mark not continue matching <code class="example">t</code> and beyond like <code class="example">*+</code> would? This is because it is non-greedy, or in other words, lazy. The anythings-mark will continue matching graphemes until a grapheme that would be matched matches an item following the anythings-mark.</p>
      <p>The example below uses an anythings-mark in the condition:</p>
      <div class="prog-pre"><span class="comment">; Simulate spreading of nasality to vowels</span><br>  a<span class="link">,</span> i<span class="link">,</span> u <span class="link">-></span> ã<span class="link">,</span> ĩ<span class="link">,</span> ũ <span class="link">/</span> <span class="regexp">{</span>ã<span class="link">,</span> ĩ<span class="link">,</span> ũ<span class="regexp">}</span><span class="regexp">&</span><span class="link">_</span> <br><span class="comment">; pabãdruliga ==> pabãdrũlĩgã</span></div>

      <h3 id="nescaBlocker"><a class="head-num">20.7</a>Blocked-anythings-mark</h3>
      <p>Blocked-anythings-mark is designed to block the spreading behaviour of the anythings-mark when certain graphemes are ahead of it. You enclose a set of graphemes inside <code class="example"><span class="regexp">&[</span></code> and <code class="example">]</code> that will block spreading. For example we might want the graphemes <code class="example">k</code> or <code class="example">g</code> to prevent the rightward spread of nasal vowels to non nasal vowels:</p>
      
      <div class="prog-pre">  a<span class="link">,</span> i<span class="link">,</span> u <span class="link">-></span> ã<span class="link">,</span> ĩ<span class="link">,</span> ũ <span class="link">/</span> <span class="regexp">{</span>ã<span class="link">,</span> ĩ<span class="link">,</span> ũ<span class="regexp">}</span><span class="regexp">&[</span>k<span class="link">,</span> g<span class="regexp">]</span><span class="link">_</span><br><span class="comment">; pabãdruliga ==> pabãdrũlĩga</span></div>

      <h2 id="nescaAdvancedRules"><a class="head-num">21</a>Advanced rules</h2>

      <h3 id="nescaTargetReference"><a class="head-num">21.1</a>Target-reference</h3>
      <p>A target-reference is a reference to the captured <code class="example">TARGET</code> graphemes. It cannot be used in <code class="example">TARGET</code>. This uses the dollar sign <code class="example">$</code>.</p>
      <p>Here are some examples where target-reference is employed:</p>
      <p><b>Full reduplication</b>:</p>
      <div class="prog-pre">  <span class="regexp">&</span> <span class="link">-></span> <span class="regexp">$$</span>
<span class="comment">; malak ==&gt; malakmalak</span></div>
      
      <p>"<b>Haplology</b>":</p>
      <div class="prog-pre">  <span class="regexp">{</span><span class="catkey">C</span><span class="regexp">}</span><span class="regexp">{</span><span class="catkey">V</span><span class="regexp">}</span><span class="regexp">(</span><span class="catkey">B</span><span class="regexp">)</span> <span class="link">-></span> <span class="operator">^</span> <span class="link">/</span> <span class="link">_</span><span class="regexp">$</span>
<span class="comment">; haplology ==> haplogy</span></div>
      <p><b>Reject a word when a word-initial consonant is identical to the next consonant</b>:</p>
      <div class="prog-pre">  <span class="catkey">C</span> <span class="link">-></span> <span class="operator">^REJECT</span> <span class="link">/</span> <span class="regexp">#</span><span class="link">_</span><span class="regexp">&[</span><span class="catkey">C</span><span class="regexp">]</span><span class="regexp">$</span></div>

      <h3 id="nescaNamedReference"><a class="head-num">21.2</a>Named-reference</h3>
      <p>Sometimes graphemes must be moved, copied, or asserted to be a certain grapheme between sounds. This is the purpose of named-reference.</p>

      <p>Firstly, a grapheme is bound to a name with a 'named-capture', to the right of the grapheme. A named-capture looks like <code class='example'>=[</code> + the name + <code class='example'>]</code>. The name can only consist of lowercase letters a to z, <code class='example'>.</code>, <code class='example'>-</code>, or <code class='example'>+</code>.</p>

      <p>The captured grapheme can then be copied, or rather, inserted, somewhere else in the transform with a 'named-reference', even before the named-capture. However, a named-reference may only be used in <code class="example">RESULT</code> or the <span class="regexp">CONDITION</span>, it cannot be used in <code class='example'>TARGET</code> or an exception. A named reference looks like <code class='example'>[$</code> + the-name + <code class='example'>]</code></p>

      <p>Here are some examples:</p>
      
      <div class="prog-pre"><span class="comment">; Delete [ʔ] between identical vowels</span>
  ʔ <span class="link">-&gt;</span> <span class="operator">^</span> <span class="regexp">/</span> [+vowel]=[identical]<span class="link">_</span>[$indentical]</div>

      <p>In this rule, we are binding the <code class='example'>V</code> category to the name <code class='example'>identical</code>, by appending <code class='example'>=[</code> + <code class='example'>identical</code> + <code class='example'>]</code> to it. Whatever this grapheme is when the condition is met, is the value of <code class='example'>identical</code>.</p>

      <div class="prog-pre"><span class="comment">; Insert an 'echo vowel' at the end of [ʔ] final words</span>
  <span class="operator">^</span> <span class="link">-&gt;</span> [$identical] <span class="regexp">/</span> <span class="regexp">{</span><span class="catkey">V</span><span class="regexp">}</span>=[identical]ʔ<span class="link">_</span><span class="regexp">#</span>
<span class="comment">; foobaʔ ==&gt; foobaʔa</span></div>

      <p>In this rule, we are binding the <code class='example'>V</code> category to the name <code class='example'>identical</code>, by appending <code class='example'>=[</code> + <code class='example'>identical</code> + <code class='example'>]</code> to it. Whatever this grapheme is when the condition is met is the value of <code class='example'>identical</code>.</p>
      <p>Then the value of <code class='example'>identical</code> is inserted into <code class='example'>RESULT</code>.</p>

      <h3 id="nescaMetathesisChange"><a class="head-num">21.3</a>Metathesis change</h3>
      <p>Simple metathesis involves a less-than-sign <code class="example">&lt;</code> in <code class="example">RESULT</code>. This will swap the first and last grapheme from the captured <code class="example">TARGET</code> graphemes:</p>
      <div class="prog-pre"><span class="comment">; Swap a plosive and nasal stop</span>
  <span class="regexp">{</span>p<span class="link">,</span> t<span class="link">,</span> k<span class="link"></span><span class="regexp">}</span><span class="regexp">{</span>m<span class="link">,</span> n<span class="regexp">}</span> <span class="link">-></span> <span class="operator">&lt;</span><br><span class="comment">; apma ==> ampa</span></div>
      
      <h3 id="nescaEngine"><a class="head-num">21.4</a>Engine</h3>
      <p>The engine statement provides useful functions that you can call at any point in the transform block. You call an engine following a <code class="example">|</code> and a space on a new line.</p>

      <ul class="paragraphian">
        <li><code class="example">decompose</code> will break-down all characters in a word into their "<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize#nfc">Unicode Normalization, Canonical Decomposition</a>" form. For example, <code class="example">ñ</code> as a singular unicode entity, \u00F1, will be broken-down into a sequence of two characters, \u006E + \u0303</li>
        <li><code class="example">compose</code> does the opposite of decompose. It converts all characters in a word to the "<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize#nfd">Unicode Normalization, Canonical Decomposition followed by Canonical Composition</a>" form. For example, <code class="example">ñ</code> as two characters \u006E\u0303, will be transformed into one character, \u00F1</li>
        <li><code class="example">capitalise</code> will convert the first character of a word to uppercase</li>
        <li><code class="example">decapitalise</code> will convert the first character of a word to lowercase</li>
        <li><code class="example">to-uppercase</code> will convert all characters of a word to uppercase</li>
        <li><code class="example">to-lowercase</code> will convert all characters of a word to lowercase</li>
        <li><code class="example">xsampa_to_ipa</code> will convert graphemes of a word written in X-SAMPA into IPA</li>
        <li><code class="example">ipa_to_xsampa</code> will convert graphemes of a word written in IPA into X-SAMPA</li>
        <li><code class="example">reverse</code> will reverse the order of graphemes in a word</li>
        <li><code class="roman-to-hangul">roman-to-hangul</code> converts characters in an arbitrary romanisation to Hangul Jamo blocks.</li>
      </ul>

      <h2 id="vocabugQuestionsAndAnswers"><a class="head-num">22</a>Questions and answers</h2>
      <p>Here are some common questions and answers about Vocabug:</p>
      
      <p><b>The Generate button is greyed out</b></p>
      <p>This means Vocabug is busy generating words for you, and will eventually become clickable again. If you think this is taking too long, perhaps you have <code class="example">force word limit</code> accidentally on.</p>

      <p><b>I received the error "Invalid regular expression"</b></p>
      <p>This error occurs because you are using Vocabug in an old browser or old browser version that does not support lookbehind. <a href="https://caniuse.com/js-regexp-lookbehind">You can check if this applies to you here</a>.</p>

      <p><b>How do I target syllables or syllable division in transforms?</b></p>
      <p>Vocabug does not have a built-in way to target syllables, but you can use a <code class="example">.</code> character as a syllable divider like <code class="example">words: $S.$S, $S.$S.$S</code>, and then reference it in transforms.</p>

      <p><b>What is a natural frequency for consonants in a language?</b></p>
     
      <p>There is no one-size-fits-all answer to this question, and different analyses of word lists may produce different data on what the general expectation is. For example, in English, /ð/ is very uncommon among all the words in English, however it is a common phoneme among sentences because of the prevalence of the words <code class="example">this</code>, <code class="example">that</code>, <code class="example">those</code> and <code class="example">the</code>. And indeed, morphology, historical sound changes and word borrowing can skew any initial control you might have over frequencies.</p>
     
      <p>However, a good rule of thumb is that phonemes that are easy to pronounce and distinguish will be the most common.</p>
     

      <p><b>How do I weight an individual optional-set?</b></p>
      <p>Using the <code class="example">Optionals-weight:</code> directive, affects the weight of all optional-sets. As of version 1, there is no direct way to weight an individual optional-set. You can however, use <code class="example">^</code> as an item in an alternator, like <code class="example">a{b, c, ^*3}</code></p>

    </section>

  </div>

  <footer>
    <ol class="breadcrumbs">
      <li>
        <a href="#myNav">Return to top</a>
      </li>
    </ol>
  </footer>
  
</body>
</html>