<!DOCTYPE html>
<html lang="en-AU" id="colour-target" class="dark-mode">
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta charset="UTF-8">
  <!-- Website information -->
  <title>Nesca</title>
  <meta name="description" content="A tool to change words.">
  <meta name="keywords" content="conlangs">
  <meta name="author" content="Neonnaut">
  <!-- Scripts and stylings -->
  <link href="style.css" rel="stylesheet" type="text/css" media="all">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
  <script src="script/theme-picker.js"></script>

  <!-- Fonts -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.1/css/all.min.css">
  <!-- Icons -->
</head>
<body>
  <nav id="myNav">
    <ol class="breadcrumbs">
      <li>
      </li>
      <li style="float: right;">
        <button id="main_menu"><i class="fa fa-bars"></i> Menu</button>
      </li>
    </ol>
  </nav>

  <div id="content">
    <section id="top">
      <div>
        <img src="img/nesca.svg" alt="Logo of astronaut" style="float: left;">

        <h1 style="margin-bottom: 10px;">Nesca<br>documentation</h1>
        <b>Version <a class="VERSION">1.0.3</a></b>
      </div>
      <br>

      <h2>Contents</h2>
      <p>TBD</p>

      <h2 id="nescaAbout"><a class="head-num">1</a>About Nesca</h2>
      <p>This is the complete documentation for <a href="./nesca.html">Nesca</a> version <a class="VERSION">1.0.3</a></p>
      <p>Nesca is a "sound change applier", it takes a set of transformation rules and applies them to words to simulate historical sound changes or under similar conditions. It also offers other word modification utilities including capitalisation and X-SAMPA to IPA. Nesca is an easy to use but powerful tool for conlangers and linguists.</p>

      <!--
      <p>Nesca has been influenced by similar SCAs, most notably: Brassica, Lexurgy, Geoff's Sound Change Applier, and KathTheDragon's SCE.</p>
      -->

      <h2 id="nescaInterface"><a class="head-num">2</a>Interface</h2>
      <ul class="paragraphian">
        <li>The textbox at the top of the program is the definition-build editor. A definition-build defines the sound changes. There will already be a default definition-build in the definition-build editor, or the previous definition-build that you applied to words</li>
        <li>Use the <code class="example">Apply</code> button to see Nesca apply your sound changes to your words. Yes, there are two apply buttons.</li>

        <li>The <i class="fa fa-trash-can"></i> button clears the definition-build editor and the output words</li>
        
        <li>The <i class="fa fa-cog"></i> and <i class="fa fa-folder"></i> button will jump to the configuration and file save / load options, respectfully</li>
        
        <li>The <code class="example">Input words</code> textbox is where you list all the words you want sound changes applied</li>

        <li>The <code class="example">Help</code> button shows this document</li>

        <li>The <i class="fa fa-file-import"></i> button shows this document</li>

        <li>The <code class="example">Output words</code> textbox is where your changed words will appear</li>
        
        <li>Use the <i class="fa fa-copy"></i> button to copy the words in <code class="example">Output words</code> to your clipboard</li>

        <li>Use the <i class="fa fa-download"></i> button to download the words in <code class="example">Output words</code> to your system</li>
      </ul>

      <h3 id="nescaOptions"><a class="head-num">2.1</a>Options</h3>
      <ul class="paragraphian">
        <li><code class="example">Word-list mode</code> will produce a list of changed words</li>
        <li><code class="example">Old-to-new mode</code> will produce a list of changed words in the format <code class="example">old word -> new word</code></li>
        <li><code class="example">Debug mode</code> will show, line by line, each step in changing each word</li>

        <li><code class="example">Input divider</code> sets the delimiter, or in other words, what the content is between each input word. It is a newline by default. Use <code class="example">\n</code> for newline</li>

        <li><code class="example">Output divider</code> sets the delimiter, or in other words, what the content is between each output word. It is a newline by default. Use <code class="example">\n</code> for newline</li>

        <li><code class="example">Sort words</code> sorts the output words in alphabetical order, or the order defined in the <code class="example">alphabet:</code> directive</li>


        <li><code class="example">Editor wrap lines</code> will make the definition-build editor jump to the next line if the line escapes the width of the definition-build editor</li>
        <li><code class="example">Show keyboard</code> will reveal a 'keyboard', a character selector, below the options. Clicking on a character will insert that character into the editor</li>

        <li>Use the buttons in the <code class="example">Themes</code> dropdown to change the colour theme of the editor</li>

      </ul>

      <h3 id="nescaSaveLoad"><a class="head-num">2.2</a>File save / load</h3>
      <ul class="paragraphian">
        <li>Use the <code class="example">Save</code> button to download your sound changes as a file called 'Nesca.txt', or what you named your file in the <code class="example">File name:</code> field</a>. The file is always a ".txt" type.</li>
        <li>Use the <code class="example">Load</code> button to load a file on your system into the file editor.</li>
        <li>Use the buttons in the <code class="example">Examples</code> dropdown to load an example into the definition-build editor</li>
      </ul>

      <h2 id="vocOverallStructure"><a class="head-num">3</a>Overall structure</h2>

      <p>A definition-build is comprised of two top-level concepts: 'directives' and 'decorators'.</p>
        
      <p>Directives are laid out like blocks and define the functions of Nesca. The primary directive is the <a href="#nescaStage">stage</a> directive, which modifies each word with transforms. The other directives define concepts that are used by this primary directives.</p>

      <p>Directives are written with their name on a newline, followed by a colon <code class="example">:</code> on the same line, then followed by a newline. The payload after declaring a directive is interpreted according to the directive's semantics. A directive ends when a new directive begins, or when there are no more lines in the definition-build. For example:</p>
      <div class="prog-pre"><code class="directive">stage</code><code class="link">:</code><br>  example</div>

      <p>Decorators change a property of a directive to modify the directive's behaviour.</p>

      <p>Decorators start on a new line above the directive they are modifying with an at sign <code class="example">@</code>, followed by the directive, a <code class="example">.</code>, the property, optional whitespace, <code class="example">=</code>, optional whitespace, and then the new value of the property. Or just the property if it's a boolean flag. For example:</p>
      <div class="prog-pre"><code class="link">@</code><code class="directive">stage</code><code class="link">.</code><code class="directive">name</code> <code class="link">=</code> <code class="attribute">"Latin-to-Portuguese"</code><br><code class="directive">stage</code><code class="link">:</code><br>  example<br></div>

      <p>To disable any directive, use the <code class="example">disabled</code> flag decorator. This has the same effect as commenting out all the lines inside the directive:</p>
      <div class="prog-pre"><code class="link">@</code><code class="directive">stage</code><code class="link">.</code><code class="directive">disabled</code><br><code class="directive">stage</code><code class="link">:</code><br>  example<br></div>

      <h3 id="vocComments"><a class="head-num">3.1</a>Comments</h3>
      <p>If a line contains a semicolon <code class="example">;</code> everything after it on that line is ignored and not interpreted as Nesca syntax -- unless <code class="example">;</code> is <a href="#vocEscapeWord">escaped</a>. You can use this to leave notes about what something does or why you made certain decisions.</p>

      <h3 id="vocAboutGraphemes"><a class="head-num">3.2</a>About graphemes</h3>
      <p>Graphemes are indivisible meaningful characters that make a word in Nesca. Phonemes can be thought of as graphemes. If we use English words <code class="example">sky</code> and <code class="example">shy</code> as examples to illustrate this, <code class="example">sky</code> is made up by the graphemes <code class="example">s</code> + <code class="example">k</code> + <code class="example">y</code>, while <code class="example">shy</code> is made up by <code class="example">sh</code> + <code class="example">y</code>.</p>

      <h3 id="vocEscapingCharacters"><a class="head-num">3.3</a>Escaping characters</h3>
      <p>A single-length character following the syntax character <code class="example">\</code> ignores any meaning it might have had in the program, including backslashes themselves. This way, anything including capital letters that have already been defined as categories and brackets (but not whitespace) can be graphemes.</p>

      <h4 id="vocEscapeTransform"><a class="head-num">3.3.1</a>Transform character escape</h4>
      <p>These are the characters you must escape if you want to use them in the <a href="#nescaStage">stage</a> directive:</p>
      <details class="dropdown-group">
        <summary class="dropdown-btn">Reveal</summary>
        <table class="styled-table">
        <thead>
          <tr>
            <th>Characters</th>
            <th>Meaning</th>
          </tr>
        </thead>

        <tbody>
          <tr>
            <td><code class="example">;</code></td>
            <td><a href="#vocComments">Comment</a></td>
          </tr>
          <tr>
            <td><code class="example">\</code></td>
            <td>Escapes a character after it</td>
          </tr>
          <tr>
            <td><code class="example">&lt;routine</code>, <code class="example">=</code> and <code class="example">&gt;</code></td>
            <td>A <a href="#nescaRoutine">routine</a> is placed after the equals sign</td>
          </tr>
          <tr>
            <td><code class="example">&lt;</code> and a space</td>
            <td>Begins a <a href="#nescaClusterfield">cluster-field</a></td>
          </tr>
          <tr>
            <td><code class="example">&[</code> and <code class="example">]</code></td>
            <td>Named escape</td>
          </tr>
          <tr>
            <td><code class="example">&gt;&gt;</code>, <code class="example">-&gt;</code>, <code class="example">=&gt;</code>, <code class="example">⇒</code> or <code class="example">→</code></td>
            <td>Indicates <a href="#nescaTheChange">change</a></td>
          </tr>
          <tr>
            <td><code class="example">,</code> or <code class="example">&nbsp;</code></td>
            <td>Separates choices</td>
          </tr>
          <tr>
            <td><code class="example">{</code> and <code class="example">}</code></td>
            <td><a href="#nescaAlternatorSet">Alternator-set</a></td>
          </tr>
          <tr>
            <td><code class="example">(</code> and <code class="example">)</code></td>
            <td><a href="#nescaOptionalatorSet">Optionalator-set</a></td>
          </tr>
          <tr>
            <td><code class="example">C</code>, <code class="example">D</code>, <code class="example">K</code>, ...</td>
            <td>Any one-length capital letter can refer to a <a href="#nescaUsingCategories">category</a></td>
          </tr>
          <tr>
            <td><code class="example">[</code> and <code class="example">]</code></td>
            <td><a href="#nescaUsingFeatures">Feature</a> matrix</td>
          </tr>
          <tr>
            <td><code class="example">^</code></td>
            <td><a href="#nescaInsertionAndDeletion">Insertion</a> when in <code class="example">TARGET</code>, <a href="#nescaInsertionAndDeletion">deletion</a> when in <code class="example">REPLACEMENT</code></td>
          </tr>
          <tr>
            <td><code class="example">0</code></td>
            <td><a href="#nescaReject">Rejects</a> a word</td>
          </tr>
          <tr>
            <td><code class="example">!</code> or <code class="example">//</code></td>
            <td>An <a href="#nescaTheException">exception</a> follows this character</td>
          </tr>
          <tr>
            <td><code class="example">_</code></td>
            <td>The underscore <code class="example">_</code> is a reference to the target</td>
          </tr>
          <tr>
            <td><code class="example">#</code></td>
            <td><a href="#nescaWordBoundary">Word boundary</a></td>
          </tr>
          <tr>
            <td><code class="example">$</code></td>
            <td><a href="#nescaSyllableBoundary">Syllable boundary</a></td>
          </tr>
          <tr>
            <td><code class="example">+</code></td>
            <td><a href="#nescaQuantifier">Quantifier</a>, matches as 1 or more of the previous grapheme</td>
          </tr>
          <tr>
            <td><code class="example">?[</code> and <code class="example">]</code></td>
            <td><a href="#nescaBoundedQuantifier">Bounded quantifier</a></td>
          </tr>
          <tr>
            <td><code class="example">:</code></td>
            <td><a href="#nescaGeminateMark">Geminate-mark</a>, duplicates the previous grapheme</td>
          </tr>
          <tr>
            <td><code class="example">*</code></td>
            <td><a href="#nescaWildcard">Wildcard</a>, matches exactly 1 of any grapheme</td>
          </tr>
          <tr>
            <td><code class="example">%[</code> and <code class="example">]</code></td>
            <td><a href="#nescaAnythingsMark">Anythings-mark</a>, matches 1 or more wildcards</td>
          </tr>
          <tr>
            <td><code class="example">%[</code> and <code class="example">|</code> and <code class="example">]</code></td>
            <td><a href="#nescaLaziness">Anythings-mark</a> with degrees or 'cowardliness'</td>
          </tr>

          <tr>
            <td><code class="example">&T</code></td>
            <td><a href="#nescaTargetMark">Target-mark</a></td>
          </tr>
          <tr>
            <td><code class="example">&M</code></td>
            <td><a href="#nescaMetathesisMark">Metathesis-mark</a></td>
          </tr>
          <tr>
            <td><code class="example">&E</code></td>
            <td><a href="#nescaEmptyMark">Empty-mark</a></td>
          </tr>
          <tr>
            <td><code class="example">&=</code></td>
            <td>Begins <a href="#nescaReference">Reference-capture</a> of a sequence of graphemes</td>
          </tr>
          <tr>
            <td><code class="example">=</code> and positive digit</td>
            <td><a href="#nescaReference">Reference-capture</a></td>
          </tr>
          <tr>
            <td>A positive digit</td>
            <td><a href="#nescaReference">Reference</a></td>
          </tr>
          <tr>
            <td><code class="example">~</code></td>
            <td><a href="#nescaAssociatemes">Based-mark</a></td>
          </tr> 

          
        </tbody>
        </table>
      </details>

      <h3 id="vocNamedEscape"><a class="head-num">3.4</a>Named escape</h3>
      <p>Named escapes, enclosed in <code class="example">&[</code> and <code class="example">]</code> allow space and combining diacritics to be used without needing to insert these characters.</p>

      <p>The supported characters are:</p>
      <details class="dropdown-group">
        <summary class="dropdown-btn">Reveal</summary>

        <table class="styled-table"><thead>
          <tr>
            <th>Escape Name</th>
            <th>Unicode Character</th>
          </tr></thead>
        <tbody>
          <tr>
            <td><code class='example'>&[Space]</code></td>
            <td> </td>
          </tr>
          <tr>
            <td><code class='example'>&[Tab]</code></td>
            <td> </td>
          </tr>
          <tr>
            <td><code class='example'>&[Newline]</code></td>
            <td> </td>
          </tr>
          <tr>
            <td><code class='example'>&[Acute]</code></td>
            <td>◌́</td>
          </tr>
          <tr>
            <td><code class='example'>&[DoubleAcute]</code></td>
            <td>◌̋</td>
          </tr>
          <tr>
            <td><code class='example'>&[Grave]</code></td>
            <td>◌̀</td>
          </tr>
          <tr>
            <td><code class='example'>&[DoubleGrave]</code></td>
            <td>◌̏</td>
          </tr>
          <tr>
            <td><code class='example'>&[Circumflex]</code></td>
            <td>◌̂</td>
          </tr>
          <tr>
            <td><code class='example'>&[Caron]</code></td>
            <td>◌̌</td>
          </tr>
          <tr>
            <td><code class='example'>&[Breve]</code></td>
            <td>◌̆</td>
          </tr>
          <tr>
            <td><code class='example'>&[BreveBelow]</code></td>
            <td>◌̮</td>
          </tr>
          <tr>
            <td><code class='example'>&[InvertedBreve]</code></td>
            <td>◌̑</td>
          </tr>
          <tr>
            <td><code class='example'>&[InvertedBreveBelow]</code></td>
            <td>◌̯</td>
          </tr>
          <tr>
            <td><code class='example'>&[TildeAbove]</code></td>
            <td>◌̃</td>
          </tr>
          <tr>
            <td><code class='example'>&[TildeBelow]</code></td>
            <td>◌̰</td>
          </tr>
          <tr>
            <td><code class='example'>&[Macron]</code></td>
            <td>◌̄</td>
          </tr>
          <tr>
            <td><code class='example'>&[MacronBelow]</code></td>
            <td>◌̠</td>
          </tr>
          <tr>
            <td><code class='example'>&[MacronBelowStandalone]</code></td>
            <td>◌˗</td>
          </tr>
          <tr>
            <td><code class='example'>&[Dot]</code></td>
            <td>◌̇</td>
          </tr>
          <tr>
            <td><code class='example'>&[DotBelow]</code></td>
            <td>◌̣</td>
          </tr>
          <tr>
            <td><code class='example'>&[Diaeresis]</code></td>
            <td>◌̈</td>
          </tr>
          <tr>
            <td><code class='example'>&[DiaeresisBelow]</code></td>
            <td>◌̤</td>
          </tr>
          <tr>
            <td><code class='example'>&[Ring]</code></td>
            <td>◌̊</td>
          </tr>
          <tr>
            <td><code class='example'>&[RingBelow]</code></td>
            <td>◌̥</td>
          </tr>
          <tr>
            <td><code class='example'>&[Horn]</code></td>
            <td>◌̛</td>
          </tr>
          <tr>
            <td><code class='example'>&[Hook]</code></td>
            <td>◌̉</td>
          </tr>
          <tr>
            <td><code class='example'>&[CommaAbove]</code></td>
            <td>◌̓</td>
          </tr>
          <tr>
            <td><code class='example'>&[CommaBelow]</code></td>
            <td>◌̦</td>
          </tr>
          <tr>
            <td><code class='example'>&[Cedilla]</code></td>
            <td>◌̧</td>
          </tr>
          <tr>
            <td><code class='example'>&[Ogonek]</code></td>
            <td>◌̨</td>
          </tr>
          <tr>
            <td><code class='example'>&[VerticalLineBelow]</code></td>
            <td>◌̩</td>
          </tr>
          <tr>
            <td><code class='example'>&[VerticalLineAbove]</code></td>
            <td>◌̍</td>
          </tr>
          <tr>
            <td><code class='example'>&[DoubleVerticalLineBelow]</code></td>
            <td>◌͈</td>
          </tr>
          <tr>
            <td><code class='example'>&[PlusSignBelow]</code></td>
            <td>◌̟</td>
          </tr>
          <tr>
            <td><code class='example'>&[PlusSignStandalone]</code></td>
            <td>◌˖</td>
          </tr>
          <tr>
            <td><code class='example'>&[uptackBelow]</code></td>
            <td>◌̝</td>
          </tr>
          <tr>
            <td><code class='example'>&[UpTackStandalone]</code></td>
            <td>◌˔</td>
          </tr>
          <tr>
            <td><code class='example'>&[LeftTackBelow]</code></td>
            <td>◌̘</td>
          </tr>
          <tr>
            <td><code class='example'>&[rightTackBelow]</code></td>
            <td>◌̙</td>
          </tr>
          <tr>
            <td><code class='example'>&[DownTackBelow]</code></td>
            <td>◌̞</td>
          </tr>
          <tr>
            <td><code class='example'>&[DownTackStandalone]</code></td>
            <td>◌˕</td>
          </tr>
          <tr>
            <td><code class='example'>&[BridgeBelow]</code></td>
            <td>◌̪</td>
          </tr>
          <tr>
            <td><code class='example'>&[BridgeAbove]</code></td>
            <td>◌͆</td>
          </tr>
          <tr>
            <td><code class='example'>&[InvertedBridgeBelow]</code></td>
            <td>◌̺</td>
          </tr>
          <tr>
            <td><code class='example'>&[SquareBelow]</code></td>
            <td>◌̻</td>
          </tr>
          <tr>
            <td><code class='example'>&[SeagullBelow]</code></td>
            <td>◌̼</td>
          </tr>
          <tr>
            <td><code class='example'>&[LeftBracketBelow]</code></td>
            <td>◌͉</td>
          </tr>
        </tbody></table>
      </details>

      <p>If you are using this, you should be very interested in the <a href="#nescaRoutine">Compose routine</a>.</p>

      <h2 id="vocAlphabetisation"><a class="head-num">4</a>The alphabet directive</h2>
      <p>The alphabet directive gives Nesca a custom alphabetisation order for words, when the sort words checkbox is selected.</p>
      <div class="prog-pre"><span class="directive">alphabet</span><code class="link">:</code>
  a<span class="link">,</span> b<span class="link">,</span> c<span class="link">,</span> e<span class="link">,</span> f<span class="link">,</span> h<span class="link">,</span> i<span class="link">,</span> k<span class="link">,</span> l<span class="link">,</span> m<span class="link">,</span> n<span class="link">,</span> o<span class="link">,</span> p<span class="link">,</span> p'<span class="link">,</span> r<span class="link">,</span> s<span class="link">,</span> t<span class="link">,</span> t'<span class="link">,</span> y</div>

      <p>This would order output words like so: <code class="example">cat</code>, <code class="example">chat</code>, <code class="example">cumin</code>, <code class="example">frog</code>, <code class="example">tray</code>, <code class="example">t'a</code>, <code class="example">yanny</code></p>

      <h2 id="vocInvisibility"><a class="head-num">5</a>The invisible directive</h2>
      <p>Sometimes you will want characters, such as syllable dividers, to be invisible to alphabetisation. You can do this by listing these characters in the invisible directive.</p>
      <div class="prog-pre"><span class="directive">invisible</span><code class="link">:</code>
  .<span class="link">,</span> '</div>
      <p> This will make these output words: <code class="example">za'ta</code>, <code class="example">'ba.ta</code>, <code class="example">'za.ta</code> be reordered into: <code class="example">'ba.ta</code>, <code class="example">za'ta</code>, <code class="example">'za.ta</code></p>

      <h2 id="vocGraphemes"><a class="head-num">6</a>The graphemes directive</h2>
      <p>The <code class="example">graphemes</code> directive tells Nesca which (multi)graphs, including character + combining diacritics, are to be treated as grapheme units when using <a href="#nescaStage">transformations</a>.</p>
      <div class="prog-pre"><span class="directive">graphemes</span><code class="link">:</code>
  a<span class="link">,</span> b<span class="link">,</span> c<span class="link">,</span> ch<span class="link">,</span> e<span class="link">,</span> f<span class="link">,</span> h<span class="link">,</span> i<span class="link">,</span> k<span class="link">,</span> l<span class="link">,</span> m<span class="link">,</span> n<span class="link">,</span> o<span class="link">,</span> p<span class="link">,</span> p'<span class="link">,</span> r<span class="link">,</span> s<span class="link">,</span> t<span class="link">,</span> t'<span class="link">,</span> y</div>
      <p>In the above example, we defined <code class="example">ch</code> as a grapheme. This would stop a rule such as <code class="example">c -> g</code> changing the word <code class="example">chat</code> into <code class="example">ghat</code>, but it will make <code class="example">cobra</code> change into <code class="example">gobra</code>.</p>

      <p>Which graphemes are 'associatemes' of their 'bases' are declared in the graphemes directive. Read more about this in <a href="#nescaAssociatemes">this section of the documentation</a>.</p>

      <h2 id="nescaStage"><a class="head-num">7</a>The stage directive</h2>
      <p>You might want to modify words to prevent certain sequences, outright reject certain words, or simulate historical sound changes. This is the purpose of transforms, which are all declared in the stage directive:</p>
      <div class="prog-pre"><span class="directive">stage</span><code class="link">:</code>
<span class="comment">; Your transforms go here</span></div>

      <p>The default transform is a rule. These should be familiar to anyone who knows a little about phonological rules. The two other types of transforms are <a href="#nescaClusterfield">cluster-fields</a> and <a href="#nescaRoutine">routines</a>.</p>

      <p>A rule can be summarised as four fields: <code class="example">CHANGE / CONDITION ! EXCEPTION</code>. The characters <code class="example">/</code> and <code class="example">!</code> that precede each field (except for the <code class="example">CHANGE</code>) are necessary for signalling each field. For example, including a <code class="example">!</code> will signal that this rule contains an exception, and all text following it until the next field marker will be interpreted as such.</p>

      <p>Every rule begins on a new line and must contain a <code class="example">CHANGE</code>. The <code class="example">CONDITION</code> or <code class="example">EXCEPTION</code> fields are optional.</p>
      <p>If you want to capture graphemes that are normally syntax characters in transforms, you will need to <a href="#vocEscapeTransform">escape them</a>.</p>

      <p>Line wrapping is allowed on the operators <code class="example">-></code>, <code class="example">=></code>, <code class="example">&gt;&gt;</code>, <code class="example">→</code>, <code class="example">⇒</code>, <code class="example">/</code> and <code class="example">!</code>. for example:</p>
      <div class="prog-pre">o <span class="link">-&gt;</span><br>x <span class="link">/</span><br>p<span class="link">_</span>p <span class="link">/</span><br>t<span class="link">_</span>t</div>


      <p>When this document uses examples to explain transformations, the last comment shows an example word transforming. For example <code class="example">; amda ==> ampa</code> means the rule will transform the word <code class="example">amda</code> into <code class="example">ampa</code></p>

      <h2 id="nescaTheChange"><a class="head-num">8</a>The change</h2>
      <p>The format of a rule's <code class="example">CHANGE</code> can be expressed as <code class="example">TARGET -> REPLACEMENT</code>.</p>
      <ul class="paragraphian">
        <li><code class="example">TARGET</code> specifies which part of the word is being changed</li>
        <li>Then followed by hyphen and greater-than-sign <code class="example">-&gt;</code>. <code class="example">-&gt;</code> can be swapped with either <code class="example">&gt;></code>, <code class="example">=&gt;</code>, <code class="example">⇒</code> or <code class="example">→</code> if you prefer</li>
        <li><code class="example">REPLACEMENT</code> is what <code class="example">TARGET</code> is changing into, or in other words, replacing</li>
      </ul>
      <p>Let's look at a simple unconditional rule:</p>
      <div class="prog-pre"><span class="comment">; Replace every &lt;o&gt; with &lt;x&gt;</span><br>  o <span class="link">-></span> x<br><span class="comment">; bodido ==> bxdidx</span></div>
      <p>In this rule, we see every instance of <code class="example">o</code> become <code class="example">x</code>.</p>

      <h3 id="nescaConcurrentChange"><a class="head-num">8.1</a>Concurrent change</h3>
      <p>Concurrent change is achieved by listing multiple graphemes in <code class="example">TARGET</code> separated by commas, and listing the same amount of replacement graphemes in <code class="example">REPLACEMENT</code> separated by commas. Changes in a concurrent change execute at the same time:</p>
      <div class="prog-pre"><span class="comment">; Switch &lt;o&gt; and &lt;a&gt; around</span><br>  o<span class="link">,</span> a <span class="link">-></span> a<span class="link">,</span> o<br><span class="comment">; boda ==> bado</span></div>
      <p>Notice that the above example is different to the example below:</p>
      <div class="prog-pre">  o <span class="link">-></span> a<br>  a <span class="link">-></span> o<br><span class="comment">; boda ==> bodo</span></div>
      <p>where each change is on its own line. We can see <code class="example">o</code> merge with <code class="example">a</code>, then <code class="example">a</code> becomes <code class="example">o</code>.</p>

      <h3 id="nescaMergingChange"><a class="head-num">8.2</a>Merging change</h3>
      <p>Instead of listing each <code class="example">REPLACEMENT</code> in a concurrent change, we can instead list just one that all the <code class="example">TARGET</code>s will merge into:</p>
      <div class="prog-pre"><span class="comment">; Merge &lt;o&gt; and &lt;a&gt; into &lt;x&gt;</span><br>  o<span class="link">,</span> a <span class="link">-></span> x<br><span class="comment">; boda ==> bxdx</span></div>
      <p>This is equivalent to:</p>
      <div class="prog-pre"><span class="comment">; Merge &lt;o&gt; and &lt;a&gt; into &lt;x&gt;</span><br>  o<span class="link">,</span> a <span class="link">-></span> x<span class="link">,</span> x<br><span class="comment">; boda ==> bxdx</span></div>

      <h3 id="nescaReject"><a class="head-num">8.3</a>Reject</h3>
      <p>To remove, or in other words, reject a word, you use a zero <code class="example">0</code> in <code class="example">REPLACEMENT</code>:</p>
      <div class="prog-pre">a<span class="link">,</span> bi <span class="link">-></span> <span class="operator">0</span></div>
      <p>In the above example, any word that contains <code class="example">a</code> or <code class="example">bi</code> will be rejected.</p>

      <h2 id="nescaInsertionAndDeletion"><a class="head-num">9</a>Insertion and deletion</h2>
      <p>Insertion requires a <a href="#nescaTheCondition">condition</a> to be present, and for a caret <code class="example">^</code> to be present in <code class="example">TARGET</code>, representing nothing.</p>
      <div class="prog-pre"><span class="comment">; Insert &lt;a&gt; in between &lt;b&gt; and &lt;t&gt;</span>
  <span class="operator">^</span> <span class="link">-></span> a <span class="link">/</span> b<span class="link">_</span>t
<span class="comment">; bt ==> bat</span></div>
      <p>Deletion happens when <code class="example">^</code> is present in <code class="example">REPLACEMENT</code>:</p>
      <div class="prog-pre"><span class="comment">; Delete every &lt;b&gt;</span>
  b <span class="link">-></span> <span class="operator">^</span>
<span class="comment">; bubda ==> uda</span></div>

      <h2 id="nescaTheCondition"><a class="head-num">10</a>The condition</h2>
      <p>Conditions follow <a href="#nescaTheChange">the change</a> and are placed after a forward slash. When a transform has a condition, the target must meet the environment described in the condition to execute.</p>
      <p>The format of a condition is <code class="example">/ BEFORE_AFTER</code></p>
      <ul class="paragraphian">
        <li>A forward slash <code class="example">/</code> begins a condition</li>
        <li><code class="example">BEFORE</code> is anything in the word before the target</li>
        <li>The underscore <code class="example">_</code> is a reference to the target in a condition</li>
        <li><code class="example">AFTER</code> is the sequence of graphemes of a word after the target</li>
      </ul>
      <p>For example:</p>
      <div class="prog-pre"><span class="comment">; Change &lt;o&gt; into &lt;x&gt; only when it is between &lt;p&gt;s</span><br>  o <span class="link">-></span> x <span class="link">/</span> p<span class="link">_</span>p<br><span class="comment">; opoptot ==> opxptot</span></div>

      <h3 id="nescaMultipleCondition"><a class="head-num">10.1</a>Multiple conditions in one rule</h3>
      <p>Multiple conditions for a single rule can be made by separating each condition with additional forward slashes. The change will happen if it meets either, or both of the conditions:</p>
      <div class="prog-pre"><span class="comment">; Change &lt;o&gt; into &lt;x&gt; only when it is between &lt;p&gt;s or &lt;t&gt;s</span><br>  o <span class="link">-></span> x <span class="link">/</span> p<span class="link">_</span>p <span class="link">/</span> t<span class="link">_</span>t<br><span class="comment">; opoptot ==> opxptxt</span></div>
      
      <h3 id="nescaWordBoundary"><a class="head-num">10.2</a>Word boundary</h3>
      <p>Hash <code class="example">#</code> matches to word boundaries. Either the beginning of the word if it is in <code class="example">BEFORE</code>, or the end of the word if it is in <code class="example">AFTER</code></p>
      <div class="prog-pre">  o <span class="link">-></span> x <span class="link">/</span> p<span class="link">_</span>p<span class="regexp">#</span><br><span class="comment">; opoppop ==> opoppxp</span></div>

      <h3 id="nescaSyllableBoundary"><a class="head-num">10.3</a>Syllable boundary</h3>
      <p>Dollar-sign <code class="example">$</code> matches to either the character <code class="example">.</code>, to any of the syllable-divider graphemes stated in the <code class="example">syllable-boundary</code> directive, or if no match, tries to match word boundaries. Either the beginning of the word if it is in <code class="example">BEFORE</code>, or the end of the word if it is in <code class="example">AFTER</code></p>
      <div class="prog-pre">  o <span class="link">-></span> x <span class="link">/</span> p<span class="link">_</span>p<span class="regexp">$</span><br><span class="comment">; o.pop.pop ==> o.pxp.pxp</span></div>

      <h4 id="nescaSyllableBoundariesDirective"><a class="head-num">10.3.1</a>Syllable boundaries directive</h4>
      <p>The syllable-boundaries directive lets you define which graphemes are to be treated as a syllable-boundary:</p>
      <div class="prog-pre"><span class="directive">syllable-boundaries</span><code class="link">:</code>
  .<span class="link">,</span> '
<span class="directive">stage</span><span class="link">:</span>
  o <span class="link">-></span> x <span class="link">/</span> p<span class="link">_</span>p<span class="regexp">$</span><br><span class="comment">; o.pop'pop ==> o.pxp'pxp</span></div>

      <!--
      <h3 id="nescaChanceCondition"><a class="head-num">14.4</a>The chance condition</h3>
      <p>The chance condition is placed following a <code class="example">?</code> as a number from 0 to 100. This number represents the chance of the transformation occuring:</p>
      <div class="prog-pre">aa <span class="link">-></span> a <span class="link">/</span> <span class="link">&lt;chance =</span> <span class="operator">30%</span><span class="link">&gt;</span></div>
      <p>In the above example, the transformation will execute only 30% of the time.</p>
      -->

      <h2 id="nescaTheException"><a class="head-num">11</a>The exception</h2>
      <p>Exceptions are placed following an exclamation mark <code class="example">!</code> and go after the condition, if there is one. Exceptions function exactly like the opposite of the condition -- when a rule has an exception, the target must meet the environment described in the exception to prevent execution:</p>
      <div class="prog-pre">aa <span class="link">-></span> a <span class="link">!</span> <span class="link">_</span><span class="regexp">#</span></div>
      <p>In the above example, the transformation will not execute if <code class="example">aa</code> is at the end of the word.</p>
      <p>If there are multiple exceptions, the transform must meet all of the exceptions for it not to execute.</p>
      <p>An alternative to using an exclamation mark is to use two forward slashes <code class="example">//</code>.</p>

      <h2 id="nescaAltAndOpt"><a class="head-num">12</a>Alternator and Optionalator</h2>
      <p>These are sets just like the sets in word-creation, but they cannot be nested.</p>

      <h3 id="nescaAlternatorSet"><a class="head-num">12.1</a>Alternator-set</h3>
      <p>Enclosed in curly braces, <code class="example">{</code> and <code class="example">}</code>, only one Item in an alternator set will be part of each sequence. For example:</p>
      <div class="prog-pre">  p<span class="regexp">{</span>w<span class="link">,</span> j<span class="regexp">}</span> <span class="link">-></span> pp</div>
      <p>The above example is equivalent to:</p>
      <div class="prog-pre">  pw<span class="link">,</span> pj <span class="link">-></span> pp</div>
      <p>These can also be used in exceptions and conditions:</p>
      <div class="prog-pre">  a <span class="link">-></span> e <span class="link">/</span> <span class="regexp">{</span>b<span class="link">,</span> d<span class="regexp">}</span><span class="link">_</span></div>

      <h3 id="nescaOptionalatorSet"><a class="head-num">12.2</a>Optionalator-set</h3>
      <p>Items in an optionalator, enclosed in <code class="example">(</code> and <code class="example">)</code> can be captured whether or not they appear as part of a grapheme or as part of a sequence of graphemes:</p>
      <div class="prog-pre"><span class="comment">; Merge &lt;x&gt; and &lt;xw&gt; into &lt;k&gt;</span><br>  x<span class="regexp">(</span>w<span class="regexp">)</span> <span class="link">-></span> k<br><span class="comment">; xwaxaħa ==> kakaħa</span></div>
      <p>Optional-set can also attach to an alternator-set:</p>
      <div class="prog-pre"><span class="comment">; Merge &lt;x&gt;, &lt;xw&gt;, &lt;ħ&gt; and &lt;ħw&gt; into &lt;k&gt;</span><br>  <span class="regexp">{</span>x<span class="link">,</span> ħ<span class="regexp">}</span><span class="regexp">(</span>w<span class="regexp">)</span> <span class="link">-></span> k<br><span class="comment">; xwaxaħa ==> kakaka</span></div>
      <p>Optionalator-set cannot be used on its own, it must be connected to other content.</p>

      <h2 id="vocCategories"><a class="head-num">13</a>Categories</h2>
      <p>Categories are declared inside the <code class="example">categories</code> directive on a line each. A category is a set of <a href="#vocAboutGraphemes">graphemes</a> with a key. The key is a singular-length capital letter. For example:</p>
      <div class="prog-pre"><span class="directive">categories</span><code class="link">:</code><br>  <span class="catkey">C</span> <span class="link">=</span> t<span class="link">,</span> n<span class="link">,</span> k<span class="link">,</span> m<span class="link">,</span> ch<span class="link">,</span> l<span class="link">,</span> ꞌ<span class="link">,</span> s<span class="link">,</span> r<span class="link">,</span> d<span class="link">,</span> h<span class="link">,</span> w<span class="link">,</span> b<span class="link">,</span> y<span class="link">,</span> p<span class="link">,</span> g</div>

      <p>This creates two groups of graphemes. <code class="example">C</code> is the group of all consonants and <code class="example">V</code> is the group of all vowels.</p>
      <p>These graphemes are separated by commas, however an alternative is to use spaces: <code class="example">C = t n k m ch l ꞌ s r d h w b y p g</code>.</p>
      
      <p>Need more than 26 categories? Nesca supports the following additional characters as the key of a category or <a href="#vocUnits">unit</a>: <code class="example">Á Ć É Ǵ Í Ḱ Ĺ Ḿ Ń Ó Ṕ Ŕ Ś Ú Ẃ Ý Ź À È Ì Ǹ Ò Ù Ẁ Ỳ Ǎ Č Ď Ě Ǧ Ȟ Ǐ Ǩ Ľ Ň Ǒ Ř Š Ť Ǔ Ž Ä Ë Ḧ Ï Ö Ü Ẅ Ẍ Ÿ Γ Δ Θ Λ Ξ Π Σ Φ Ψ Ω</code></p>

      <p>You can use categories inside categories, as long as the referenced category has previously been defined. For example:</p>
      <div class="prog-pre"><span class="directive">categories</span><code class="link">:</code>
  <span class="catkey">L</span> <span class="link">=</span> aa<span class="link">,</span> ii<span class="link">,</span> ee<span class="link">,</span> oo
  <span class="catkey">V</span> <span class="link">=</span> a<span class="link">,</span> i<span class="link">,</span> e<span class="link">,</span> o<span class="link">,</span> <span class="catkey">L</span></div>
      
      <h3 id="nescaUsingCategories"><a class="head-num">13.1</a>Using categories</h3>
      <p>You can reference categories in transforms. The category will behave in the same way as an alternator set:</p>
      <div class="prog-pre"><span class="directive">categories</span><span class="link">:</span>
  <span class="catkey">B</span> <span class="link">=</span> x<span class="link">,</span> y<span class="link">,</span> z<br><span class="directive">stage</span><span class="link">:</span><br>  <span class="catkey">B</span> <span class="link">-></span> <span class="operator">^</span><br><code class="comment">; xapay ==> apa</code></div>

      <p>If the category is inside a set, it MUST be listed as an item on its own:</p>
      <div class="prog-pre"><span class="directive">categories</span><span class="link">:</span>
  <span class="catkey">B</span> <span class="link">=</span> x<span class="link">,</span> y
<span class="directive">stage</span><span class="link">:</span>
  <span class="regexp">{</span><span class="catkey">B</span><span class="link">,</span> z<span class="regexp">}</span>v <span class="link">-></span> <span class="operator">^</span><br><code class="comment">; xvayazv ==> aya</code></div>

<p>This is to say <code class="example">{Bz}v -> ^</code> is invalid.</p>

      <h2 id="nescaFeatures"><a class="head-num">14</a>Features</h2>
      <p>Let's say you had the grapheme, or rather, phoneme /i/ and wanted to capture it by its distinctive vowel features, <code class="example">+high</code>, <code class="example">-round</code> and <code class="example">+front</code>, and turn it into a phoneme marked with <code class="example">+high</code>, <code class="example">-round</code> and <code class="example">+back</code> features, perhaps /ɯ/. Nesca's features directive and feature matrices let you do this. Nesca's features can be described as binary and 'non-carryover'.</p>
      <p>The key of all features must consist of lowercase letters a to z, uppercase letters a to z, <code class="example">.</code>, <code class="example">-</code> or <code class="example">+</code></p>

      <h3 id="nescaProFeature"><a class="head-num">14.1</a>Pro-feature</h3>
      <p>A feature prepended with a plus sign <code class="example">+</code> is a 'pro-feature'. For example <code class="example">+voice</code>. We can define a set of graphemes that are marked by this feature by using this pro-feature. For example:</p>
      <div class="prog-pre"><span class="directive">features</span><span class="link">:</span>
  <span class="catkey">+voice</span> <span class="link">=</span> b<span class="link">,</span> d<span class="link">,</span> g<span class="link">,</span> v<span class="link">,</span> z</div>

      <h3 id="nescaAntiFeature"><a class="head-num">14.2</a>Anti-feature</h3>
      <p>A feature prepended with a minus sign <code class="example">-</code> is an 'anti-feature'. For example <code class="example">-voice</code>. We can define a set of graphemes that are marked by a lack of this feature by using this anti-feature. For example:</p>
      <div class="prog-pre"><span class="directive">features</span><span class="link">:</span>
  <span class="catkey">-voice</span> <span class="link">=</span> p<span class="link">,</span> t<span class="link">,</span> k<span class="link">,</span> f<span class="link">,</span> s</div>

      <h3 id="nescaParaFeature"><a class="head-num">14.3</a>Para-feature</h3>
      <p>A feature prepended with a greater-than-sign <code class="example">&gt;</code> is a 'para-feature'. A para-feature is simply a pro-feature where the graphemes marked as the anti-feature of this feature are the graphemes in the <code class="example">graphemes:</code> directive that are not not marked by this para-feature:</p>
      <div class="prog-pre"><span class="directive">graphemes</span><span class="link">:</span>
  a<span class="link">,</span> b<span class="link">,</span> h<span class="link">,</span> i<span class="link">,</span> k<span class="link">,</span> n<span class="link">,</span> o<span class="link">,</span> t
<span class="directive">features</span><span class="link">:</span>
  <span class="catkey">&gt;vowel</span> <span class="link">=</span> a<span class="link">,</span> i<span class="link">,</span> o</div>
      <p>Is equivalent to the below example:</p>
      <div class="prog-pre"><span class="directive">features</span><span class="link">:</span>
  <span class="catkey">+vowel</span> <span class="link">=</span> a<span class="link">,</span> i<span class="link">,</span> o<br>  <span class="catkey">-vowel</span> <span class="link">=</span> b<span class="link">,</span> h<span class="link">,</span> k<span class="link">,</span> n<span class="link">,</span> t</div>

      <p>'Where does this leave graphemes that are not marked by either the pro-feature or the anti-feature of a feature?', you might ask. Such graphemes are <em>unmarked</em> by that feature.</p>

      <h3 id="nescaFeatureInFeature"><a class="head-num">14.4</a>Referencing features inside features</h3>

      <p>Features can be referenced inside features. For example:</p>
      <div class="prog-pre"><span class="directive">features</span><span class="link">:</span>
  <span class="catkey">+vowel</span> <span class="link">=</span> a<span class="link">,</span> i<span class="link">,</span> o<br>  <span class="catkey">+non-yod</span> <span class="link">=</span> <span class="catkey">+vowel</span><span class="link">,</span> <span class="operator">^</span>i</div>

      <p>Use a caret in front of a grapheme to ensure that that grapheme is not part of the pro/anti/para-feature. In the example above, the pro-feature '<code class="example">+non-yod</code>' is composed of the graphemes <code class="example">a</code> and <code class="example">o</code> -- the grapheme <code class="example">i</code> is not part of this pro-feature. Due to the recursive nature of nested features, this removed grapheme will be removed... aggressively. For example, If <code class="example">+non-yod</code> were to be referenced in a different feature, that feature would always not have <code class="example">i</code> as a grapheme.</p>

      <h3 id="nescaUsingFeatures"><a class="head-num">14.5</a>Using Features</h3>

      <p>To capture graphemes that are marked by features in a transform, the features must be listed in a 'feature-matrix' surrounded by <code class="example">[</code> and <code class="example">]</code>. The graphemes in a word must be marked by each pro-/anti-feature in the feature-matrix to be captured. For example if a feature-matrix <code class="example">[+high, +back]</code> captures the graphemes: <code class="example">u, ɯ</code>, another feature-matrix <code class="example">[+high, +back, -round]</code> would capture <code class="example">ɯ</code> only.</p>
      <p>The very simple example below is written to change all voiceless graphemes that have a voiced counterpart into their voiced counterparts:</p>

      <div class="prog-pre"><span class="directive">features</span><span class="link">:</span>
  <span class="catkey">-voice</span> <span class="link">=</span> p<span class="link">,</span> t<span class="link">,</span> k<span class="link">,</span> f<span class="link">,</span> s
  <span class="catkey">+voice</span> <span class="link">=</span> b<span class="link">,</span> d<span class="link">,</span> g<span class="link">,</span> v<span class="link">,</span> z

<span class="directive">stage</span><span class="link">:</span>
  <span class="catkey">[-voice]</span> <span class="link">-&gt;</span> <span class="catkey">[+voice]</span>
<span class="comment">; tamefa ==&gt; dameva</span></div>

      <p>In this rule, in <code class="example">REPLACEMENT</code>, <code class="example">[+voice]</code> has a symmetrical one-to-one change of graphemes from the graphemes in <code class="example">[-voice]</code> in <code class="example">TARGET</code>, leading to a concurrent change. Let's quickly imagine a scenario where the only <code class="example">[+voice]</code> grapheme was <code class="example">b</code>. The result will be a merging of all <code class="example">-voice</code> graphemes into <code class="example">b</code>: <code class="example">tamepfa ==&gt; bamebba</code>.</p>

      <p>It should be noted that feature-matrices in <code class="example">TARGET</code> have no carryover to feature-matrices in <code class="example">REPLACEMENT</code>. For example, in a bogus rule such as <code class="example">o -> [+high]</code> Nesca will <b>not</b> try to transform <code class="example">&lt;o&gt;</code> into it's [+high] counterpart, it will try and replace <code class="example">&lt;o&gt;</code> with some grapheme marked as <code class="example">[+high]</code> and will probably fail unless only one grapheme is marked as <code class="example">[+high]</code>.</p>

            <p>If the category is inside a set, it MUST be listed as an item on its own:</p>
      <div class="prog-pre"><span class="directive">features</span><span class="link">:</span>
  <span class="catkey">+example</span> <span class="link">=</span> x<span class="link">,</span> y
<span class="directive">stage</span><span class="link">:</span>
  <span class="regexp">{</span><code class='regexp'>[</code><span class="catkey">+example</span><code class='regexp'>]</code><span class="link">,</span> z<span class="regexp">}</span>v <span class="link">-></span> <span class="operator">^</span><br><code class="comment">; xvayazv ==> aya</code></div>

<p>This is to say <code class="example">{[+voiced]z}v -> ^</code> is invalid.</p>

      <h3 id="nescaFeatureField"><a class="head-num">14.6</a>The feature-field directive</h3>
      <p>Feature-fields allow graphemes to be easily marked by multiple features in table format.</p>
      <p>The graphemes being marked by the features are listed on the first row. The features are listed in the first column.</p>
      <p>For example:</p>
      <div class="prog-pre"><code class='directive'>feature-field</code><code class="link">:</code>
           m n p b t d k g s h l j
voice      <code class="attribute">+</code> <code class="attribute">+</code> <code class='regexp'>-</code> <code class="attribute">+</code> <code class='regexp'>-</code> <code class="attribute">+</code> <code class='regexp'>-</code> <code class="attribute">+</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class="attribute">+</code> <code class="attribute">+</code>
plosive    <code class='regexp'>-</code> <code class='regexp'>-</code> <code class="attribute">+</code> <code class="attribute">+</code> <code class="attribute">+</code> <code class="attribute">+</code> <code class="attribute">+</code> <code class="attribute">+</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code>
nasal      <code class="attribute">+</code> <code class="attribute">+</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code>
fricative  <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class="attribute">+</code> <code class="attribute">+</code> <code class='regexp'>-</code> <code class='regexp'>-</code>
approx     <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class="attribute">+</code> <code class="attribute">+</code>
labial     <code class="attribute">+</code> <code class='regexp'>-</code> <code class="attribute">+</code> <code class="attribute">+</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code>
alveolar   <code class='regexp'>-</code> <code class="attribute">+</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class="attribute">+</code> <code class="attribute">+</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class="attribute">+</code> <code class='regexp'>-</code> <code class="attribute">+</code> <code class='regexp'>-</code>
palatal    <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class="attribute">+</code>
velar      <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class="attribute">+</code> <code class="attribute">+</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code>
glottal    <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class="attribute">+</code> <code class='regexp'>-</code> <code class='regexp'>-</code>


<code class='directive'>feature-field</code><code class="link">:</code>
       a e i o
high   <code class='regexp'>-</code> <code class='regexp'>-</code> <code class="attribute">+</code> <code class='regexp'>-</code>
mid    <code class='regexp'>-</code> <code class="attribute">+</code> <code class='regexp'>-</code> <code class="attribute">+</code>
low    <code class="attribute">+</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code>
front  <code class='regexp'>-</code> <code class="attribute">+</code> <code class="attribute">+</code> <code class='regexp'>-</code>
back   <code class="attribute">+</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class="attribute">+</code>
round  <code class='regexp'>-</code> <code class='regexp'>-</code> <code class='regexp'>-</code> <code class="attribute">+</code></div>
      <ul class="paragraphian">
        <li>A <code class="example">+</code> means to mark the grapheme by that feature's pro-feature</li>
        <li>A <code class="example">-</code> means to mark the grapheme by that feature's anti-feature</li>
        <li>A <code class="example">.</code> means to leave the grapheme unmarked by that feature</li>
      </ul>
      <p>Here are some matrices of these features and which graphemes they would capture:</p>
      <ul class="paragraphian">
        <li><code class="example">[+plosive]</code> captures the graphemes <code class="example">b, d, g, p, t, k</code></li>
        <li><code class="example">[+voiced, +plosive]</code> captures the graphemes <code class="example">b, d, g</code></li>
        <li><code class="example">[+voiced, +labial, +plosive]</code> captures the grapheme <code class="example">b</code></li>
      </ul>



      <h2 id="nescaWildcardsAndQuantifiers"><a class="head-num">15</a>Wildcards and quantifiers</h2>
      <p>Wildcards and the like in this section are special tokens that can represent arbitrary amounts of arbitrary graphemes, which is especially useful when you don't know precisely how many, or of what kind of grapheme there will be between two target graphemes in a word.</p>

      <h3 id="nescaQuantifier"><a class="head-num">15.1</a>Quantifier</h3>
      <p>Quantifier, using <code class="example">+</code>, will match once or as many times as possible to the grapheme to the left of it. Quantifier cannot be used in <code class="example">REPLACEMENT</code>:</p>
      <div class="prog-pre">  a<span class="regexp">+</span> <span class="link">-></span> o<br><code class="comment">; raraaaaa ==> roro</code></div>

      <h3 id="nescaBoundedQuantifier"><a class="head-num">15.2</a>Bounded quantifier</h3>
      <p>The bounded quantifier matches as many times its digit(s), enclosed in <code class="example">?[</code> and <code class="example">]</code>, to the things to the left.</p>
      <div class="prog-pre"><span class="comment">; Change &lt;o&gt; into &lt;x&gt; only when preceded by three &lt;r&gt;s</span><br>  o <span class="link">-></span> x <span class="link">/</span> r<span class="regexp">?[</span>3<span class="regexp">]</span><span class="link">_</span>
<code class="comment">; ororrro ==> ororrrx</code></div>

      <p>The digits in the quantifier can also be a range:</p>
      <div class="prog-pre"><span class="comment">; Change a sequence of 2 to 4 &lt;o&gt;s into &lt;x&gt;</span><br>  o<span class="regexp">?[</span>2<span class="link">,</span>4<span class="regexp">]</span> <span class="link">-></span> x
<code class="comment">; tootooooo ==> txtxo</code></div>


      <p>At the beginning of the list, <code class="example">,</code> represents all the possible numbers lower than the number to the right, not including zero.</p>
      <div class="prog-pre"><span class="comment">; Change a sequence of 1 to 4 &lt;o&gt;s into &lt;x&gt;</span><br>  o<span class="regexp">?[</span><span class="link">,</span>4<span class="regexp">]</span> <span class="link">-></span> x
<code class="comment">; tootooooo ==> txtx</code></div>

      <p>And finally at the end of the list, <code class="example">,</code> represents all possible numbers larger than the number to the the left</p>
        <div class="prog-pre"><span class="comment">; Change a sequence of 4 to as many as possible &lt;o&gt;s into &lt;x&gt;</span><br>  o<span class="regexp">?[</span>4<span class="regexp"><span class="link">,</span>]</span> <span class="link">-></span> x
<code class="comment">; toootooooo ==> toootx</code></div>

      <p>A bounded quantifier can be used in <code class="example">REPLACEMENT</code> as long as there is a definite maximum quantity. Or in other words, you cannot produce an infinite amount of something!</p>

      <h3 id="nescaGeminateMark"><a class="head-num">15.3</a>Geminate-mark</h3>
      <p>Geminate-mark using colon <code class="example">:</code>, will duplicate the grapheme, or grapheme from a set or category, to the left of it. In other words, you can capture an item only when it is geminated using the geminate-mark:</p>
      <div class="prog-pre">  a<span class="regexp">:</span> <span class="link">-></span> o<br><code class="comment">; aaata => oata</code></div>

      <p>Unlike quantifier, a geminate mark can be used in <code class="example">REPLACEMENT</code>:</p>

      <div class="prog-pre">  a <span class="link">-></span> a<span class="regexp">:</span><br><code class="comment">; tat => taat</code></div>

      <h3 id="nescaKleeneStar"><a class="head-num">15.4</a>Kleene-star</h3>
      <p>Occasionally, you may want to match a grapheme whether it exists, there is one of it, or there is multiple of it consecutively, known as a "Kleene-star". There is <b>no</b> dedicated character for a Kleene star. Instead, you wrap the content followed by a quantifier, in an optionalator:</p>
      <div class="prog-pre">  u<span class="regexp">(</span>a<span class="regexp">+)</span> <span class="link">-></span> o<br><code class="comment">; ruaruaaaaa ==> roro</code></div>

      <h3 id="nescaWildcard"><a class="head-num">15.5</a>Wildcard</h3>
      <p>Wildcard, using asterisk <code class="example">*</code>, will match once to any grapheme. Wildcard does not match word boundaries. Wildcard cannot be used in <code class="example">REPLACEMENT</code>:</p>
      <div class="prog-pre"><code class="comment">; Any grapheme becomes &lt;x&gt; when any grapheme follows it</code><br>  <span class="regexp">*</span> <span class="link">-></span> x <span class="link">/</span> <span class="link">_</span><span class="regexp">*</span><br><code class="comment">; aomp ==> xxxp</code></div>
      <p>Wildcard can be placed by itself inside an <a href="#nescaOptionalatorSet">optionalator</a> <code class="example">(*)</code>, thereby allowing it to match nothing as well.</p>

      <h3 id="nescaAnythingsMark"><a class="head-num">15.6</a>Anythings-mark</h3>
      <p>The anythings-mark uses percent sign <code class="example">%</code> and a pair of square brackets <code class="example">[</code> and <code class="example">]</code>. It will match as many (but not zero) times to any grapheme. For example:</p>
      <div class="prog-pre">  b<span class="regexp">%[]</span> <span class="link">-></span> x<br><code class="comment">; abitto => ax</code></div>
      <p>As we can see, the rule matched <code class="example">b</code> and greedily matched every and any grapheme after it.</p>
      <p>The example below uses an anythings-mark in the condition:</p>
      <div class="prog-pre"><span class="comment">; Simulate spreading of nasality to vowels</span><br>  a<span class="link">,</span> i<span class="link">,</span> u <span class="link">-></span> ã<span class="link">,</span> ĩ<span class="link">,</span> ũ <span class="link">/</span> <span class="regexp">{</span>ã<span class="link">,</span> ĩ<span class="link">,</span> ũ<span class="regexp">}</span><span class="regexp">%[]</span><span class="link">_</span> <br><span class="comment">; pabãdruliga ==> pabãdrũlĩgã</span></div>

      <h3 id="nescaLaziness"><a class="head-num">15.6.1</a>Laziness and cowardliness</h3>
      <p>By listing graphemes and grapheme sequences inside the square brackets, we can alter the "greedy" behaviour of an anythings-mark with degrees of "laziness" and 'cowardliness'.</p>

      <p><b>Consuming negative lookahead, AKA "laziness"</b>:</p>

      <p>Sometimes it is necessary to for the anythings mark to consume graphemes we are monitoring for, and then stop consuming:</p>

      <div class="prog-pre">  b<span class="regexp">%[</span>t<span class="link">,</span> d<span class="regexp">]</span> <span class="link">-></span> x<br><code class="comment">; babitto => xto</code></div>

      <p>As we can see, the rule matched <code class="example">b</code> followed by anything else until it reached the first <code class="example">t</code>, consumed that, then stopped matching. This behaviour in Regular Expression terminology is called "lazy".</p>

      <p>As already stated, the items to check for greediness can be a sequence of graphemes:</p>

      <div class="prog-pre">  b<span class="regexp">%[</span>tr<span class="regexp">,</span> d<span class="regexp">]</span> <span class="link">-></span> x<br><code class="comment">; batitro => xo</code></div>

      <p>Sets, categories and features can also be used when monitoring for laziness and cowardliness:</p>

            <div class="prog-pre"><span class="comment">; capture up to a plosive + &lt;r&gt; cluster</span>
  <span class="regexp">%[</span><span class="regexp">{</span>p<span class="link">,</span>t<span class="link">,</span>k<span class="regexp">}</span>r<span class="regexp">]</span> <span class="link">-></span> x 
<span class="comment">; kotatros -> xos</span></div> 

      <p><b>Negative lookahead, AKA 'cowardliness'</b>:</p>

      <p>Sometimes it is necessary for graphemes to block the spread <i>without</i> having them be consumed, which I have dubbed 'cowardliness'. To do this put a pipe <code class="example">|</code> between the lazy and cowardly items. For example we might want the graphemes <code class="example">k</code> or <code class="example">g</code> to prevent the rightward spread of nasal vowels to non nasal vowels:</p>
      
      <div class="prog-pre">  a<span class="link">,</span> i<span class="link">,</span> u <span class="link">-></span> ã<span class="link">,</span> ĩ<span class="link">,</span> ũ <span class="link">/</span> <span class="regexp">{</span>ã<span class="link">,</span> ĩ<span class="link">,</span> ũ<span class="regexp">}</span><span class="regexp">%[</span><span class="link">|</span> k<span class="link">,</span> g<span class="regexp">]</span><span class="link">_</span><br><span class="comment">; pabãdruliga ==> pabãdrũlĩga</span></div>

      <h2 id="nescaClusterfield"><a class="head-num">16</a>Cluster-field</h2>
      <p>Cluster-field is a way to target sequences of graphemes and change them. They are laid out as tables, and start with <code class="example">&lt;</code> followed by a space. The first part of a sequence is in the first column, and the second part is in the first row. The clusterfield ends with a <code class="example">&gt;</code> on its own line. For example:</p>
      <div class="prog-pre"><span class="directive">&lt;</span> p  t  k  m  n
m <span class="attribute">+</span>  nt nk <span class="attribute">+</span>  mm 
n mp <span class="attribute">+</span>  <span class="attribute">+</span>  nn <span class="attribute">+</span>
<span class="directive">&gt;</span></div>

      <ul class="paragraphian">
        <li>In this example, <code class="example">np</code> becomes <i>mp</i> and <code class="example">mt</code> becomes <i>nt</i></li>
        <li>These are executed concurrently just like concurrent changes. Their order does not matter</li>
        <li><code class="example">+</code> means to not change the target cluster at all</li>
        <li>Cluster-fields can use <code class="example">0</code> to reject the word if it contains that sequence</li>
        <li>Cluster-fields can use <code class="example">^</code> to delete the target sequence</li>
      </ul>

      <h2 id="nescaAdvancedRules"><a class="head-num">17</a>Advanced transforms</h2>

      <h3 id="nescaRoutine"><a class="head-num">17.1</a>Routine</h3>
      <p>The routine transform provides useful functions that you can call at any point in the transform block. You call a routine on a newline with <code class="example">&lt;routine</code>, optional space, <code class="example">=</code>, optional space, the routine, and a closing <code class="example">&gt;</code>.</p>

      <p>The routines are:</p>
      <ul class="paragraphian">
        <li><code class="example">decompose</code> will break-down all characters in a word into their "<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize#nfc">Unicode Normalization, Canonical Decomposition</a>" form. For example, <code class="example">ñ</code> as a singular unicode entity, \u00F1, will be broken-down into a sequence of two characters, \u006E + \u0303</li>
        <li><code class="example">compose</code> does the opposite of decompose. It converts all characters in a word to the "<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize#nfd">Unicode Normalization, Canonical Decomposition followed by Canonical Composition</a>" form. For example, <code class="example">ñ</code> as two characters \u006E + \u0303, will be transformed into one character, \u00F1</li>
        <li><code class="example">capitalise</code> will convert the first character of a word to uppercase</li>
        <li><code class="example">decapitalise</code> will convert the first character of a word to lowercase</li>
        <li><code class="example">to-uppercase</code> will convert all characters of a word to uppercase</li>
        <li><code class="example">to-lowercase</code> will convert all characters of a word to lowercase</li>
        <li><code class="example">reverse</code> will reverse the order of graphemes in a word</li>
        
        <li><code class="example">xsampa-to-ipa</code> will convert characters of a word written in X-Sampa into IPA. <code class="example">ipa-to-xsampa</code> will convert them back
        
          <details class="dropdown-group">
            <summary class="dropdown-btn">Reveal</summary>

            <table class="styled-table">
              <thead>
                <tr>
                  <th>X-SAMPA</th>
                  <th>IPA</th>
                </tr>
              </thead>
            <tbody>
              <tr><td>b_&lt;</td><td>ɓ</td></tr>
              <tr><td>d_&lt;</td><td>ɗ</td></tr>
              <tr><td>d`</td><td>ɖ</td></tr>
              <tr><td>g_&lt;</td><td>ɠ</td></tr>
              <tr><td>h\</td><td>ɦ</td></tr>
              <tr><td>j\</td><td>ʝ</td></tr>
              <tr><td>l\</td><td>ɺ</td></tr>
              <tr><td>l`</td><td>ɭ</td></tr>
              <tr><td>n`</td><td>ɳ</td></tr>
              <tr><td>p\</td><td>ɸ</td></tr>
              <tr><td>r\</td><td>ɹ</td></tr>
              <tr><td>r\`</td><td>ɻ</td></tr>
              <tr><td>r`</td><td>ɽ</td></tr>
              <tr><td>s\</td><td>ɕ</td></tr>
              <tr><td>s`</td><td>ʂ</td></tr>
              <tr><td>t`</td><td>ʈ</td></tr>
              <tr><td>x\</td><td>ɧ</td></tr>
              <tr><td>z\</td><td>ʑ</td></tr>
              <tr><td>z`</td><td>ʐ</td></tr>
              <tr><td>A</td><td>ɑ</td></tr>
              <tr><td>B</td><td>β</td></tr>
              <tr><td>B\</td><td>ʙ</td></tr>
              <tr><td>C</td><td>ç</td></tr>
              <tr><td>D</td><td>ð</td></tr>
              <tr><td>E</td><td>ɛ</td></tr>
              <tr><td>F</td><td>ɱ</td></tr>
              <tr><td>G</td><td>ɣ</td></tr>
              <tr><td>G\</td><td>ɢ</td></tr>
              <tr><td>G\_&lt;</td><td>ʛ</td></tr>
              <tr><td>H</td><td>ɥ</td></tr>
              <tr><td>H\</td><td>ʜ</td></tr>
              <tr><td>I</td><td>ɪ</td></tr>
              <tr><td>J</td><td>ɲ</td></tr>
              <tr><td>J\</td><td>ɟ</td></tr>
              <tr><td>J\_&lt;</td><td>ʄ</td></tr>
              <tr><td>K</td><td>ɬ</td></tr>
              <tr><td>K\</td><td>ɮ</td></tr>
              <tr><td>L</td><td>ʎ</td></tr>
              <tr><td>L\</td><td>ʟ</td></tr>
              <tr><td>M</td><td>ɯ</td></tr>
              <tr><td>M\</td><td>ɰ</td></tr>
              <tr><td>N</td><td>ŋ</td></tr>
              <tr><td>N\</td><td>ɴ</td></tr>
              <tr><td>O</td><td>ɔ</td></tr>
              <tr><td>O\</td><td>ʘ</td></tr>
              <tr><td>v\</td><td>ʋ</td></tr>
              <tr><td>P</td><td>ʋ</td></tr>
              <tr><td>Q</td><td>ɒ</td></tr>
              <tr><td>R</td><td>ʁ</td></tr>
              <tr><td>R\</td><td>ʀ</td></tr>
              <tr><td>S</td><td>ʃ</td></tr>
              <tr><td>T</td><td>θ</td></tr>
              <tr><td>U</td><td>ʊ</td></tr>
              <tr><td>V</td><td>ʌ</td></tr>
              <tr><td>W</td><td>ʍ</td></tr>
              <tr><td>X</td><td>χ</td></tr>
              <tr><td>X\</td><td>ħ</td></tr>
              <tr><td>Y</td><td>ʏ</td></tr>
              <tr><td>Z</td><td>ʒ</td></tr>
              <tr><td>"</td><td>ˈ◌</td></tr>
              <tr><td>%</td><td>ˌ◌</td></tr>
              <tr><td>:</td><td>◌ː</td></tr>
              <tr><td>:\</td><td>◌ˑ</td></tr>
              <tr><td>@</td><td>ə</td></tr>
              <tr><td>@\</td><td>ɘ</td></tr>
              <tr><td>@`</td><td>ɚ</td></tr>
              <tr><td>{</td><td>æ</td></tr>
              <tr><td>}</td><td>ʉ</td></tr>
              <tr><td>1</td><td>ɨ</td></tr>
              <tr><td>2</td><td>ø</td></tr>
              <tr><td>3</td><td>ɜ</td></tr>
              <tr><td>3\</td><td>ɞ</td></tr>
              <tr><td>4</td><td>ɾ</td></tr>
              <tr><td>5</td><td>ɫ</td></tr>
              <tr><td>6</td><td>ɐ</td></tr>
              <tr><td>7</td><td>ɤ</td></tr>
              <tr><td>8</td><td>ɵ</td></tr>
              <tr><td>9</td><td>œ</td></tr>
              <tr><td>&</td><td>ɶ</td></tr>
              <tr><td>?</td><td>ʔ</td></tr>
              <tr><td>?\</td><td>ʕ</td></tr>
              <tr><td>&lt;\</td><td>ʢ</td></tr>
              <tr><td>>\</td><td>ʡ</td></tr>
              <tr><td>^</td><td>ꜛ</td></tr>
              <tr><td>!</td><td>ꜜ</td></tr>
              <tr><td>!\</td><td>ǃ</td></tr>
              <tr><td>|</td><td>|</td></tr>
              <tr><td>|\</td><td>ǀ</td></tr>
              <tr><td>||</td><td>‖</td></tr>
              <tr><td>|\\|\</td><td>ǁ</td></tr>
              <tr><td>=\</td><td>ǂ</td></tr>
              <tr><td>-\</td><td>‿</td></tr>

            </tbody>
            </table>
          </details>

        </li>

        <li><code class="example">latin-to-hangul</code> converts, or rather, transliterates characters written in an arbitrary romanisation into Hangul Jamo blocks. <code class="example">hangul-to-latin</code> converts them back.
        <details class="dropdown-group">
        <summary class="dropdown-btn">Reveal</summary>

          <table class="styled-table">
          <caption>Initial and final jamo</caption>
          <thead>
            <tr>
              <th>A romanisation</th>
              <th>Initial</th>
              <th>Final</th>
            </tr>
          </thead>
          <tbody>
            <tr><td>k</td><td>ㄱ</td><td>ㄱ</td></tr>
            <tr><td>gk</td><td>ㄲ</td><td>ㄲ</td></tr>
            <tr><td>n</td><td>ㄴ</td><td>ㄴ</td></tr>
            <tr><td>t</td><td>ㄷ</td><td>ㄷ</td></tr>
            <tr><td>dt</td><td>ㄸ</td><td></td></tr>
            <tr><td>r</td><td>ㄹ</td><td>ㄹ</td></tr>
            <tr><td>m</td><td>ㅁ</td><td>ㅁ</td></tr>
            <tr><td>p</td><td>ㅂ</td><td>ㅂ</td></tr>
            <tr><td>bp</td><td>ㅃ</td><td></td></tr>
            <tr><td>s</td><td>ㅅ</td><td>ㅅ</td></tr>
            <tr><td>z</td><td>ㅆ</td><td>ㅆ</td></tr>
            <tr><td>c</td><td>ㅈ</td><td>ㅈ</td></tr>
            <tr><td>j</td><td>ㅉ</td><td></td></tr>
            <tr><td>ch</td><td>ㅊ</td><td>ㅊ</td></tr>
            <tr><td>kh</td><td>ㅋ</td><td>ㅋ</td></tr>
            <tr><td>th</td><td>ㅌ</td><td>ㅌ</td></tr>
            <tr><td>ph</td><td>ㅍ</td><td>ㅍ</td></tr>
            <tr><td>x</td><td>ㅎ</td><td>ㅎ</td></tr>
            <tr><td>gn</td><td></td><td>ㅇ</td></tr>
          </tbody>
          </table>

          <table class="styled-table">
          <caption>Medial jamo</caption>
          <thead>
            <tr>
              <th>A romanisation</th>
              <th>Hangul</th>
            </tr>
          </thead>
          <tbody>
            <tr><td>a</td><td>ㅏ</td></tr>
            <tr><td>ẹ</td><td>ㅐ</td></tr>
            <tr><td>ọ</td><td>ㅓ</td></tr>
            <tr><td>e</td><td>ㅔ</td></tr>
            <tr><td>o</td><td>ㅗ</td></tr>
            <tr><td>u</td><td>ㅜ</td></tr>
            <tr><td>ụ</td><td>ㅡ</td></tr>
            <tr><td>i</td><td>ㅣ</td></tr>
            <tr><td>wa</td><td>ㅘ</td></tr>
            <tr><td>wẹ</td><td>ㅙ</td></tr>
            <tr><td>wọ</td><td>ㅝ</td></tr>
            <tr><td>we</td><td>ㅞ</td></tr>
            <tr><td>wi</td><td>ㅚ</td></tr>
            <tr><td>uí</td><td>ㅟ</td></tr>
            <tr><td>ụí</td><td>ㅢ</td></tr>
            <tr><td>ya</td><td>ㅑ</td></tr>
            <tr><td>yẹ</td><td>ㅒ</td></tr>
            <tr><td>yọ</td><td>ㅕ</td></tr>
            <tr><td>ye</td><td>ㅖ</td></tr>
            <tr><td>yo</td><td>ㅛ</td></tr>
            <tr><td>yu</td><td>ㅠ</td></tr>
          </tbody>
          </table>
          </details>
          <p>When there is no initial to be found, the jamo will have an initial Ieung. Forming an initial of the next jamo is preferred over creating a final for the current jamo</p>
      </li>

      <li><code class="example">latin-to-greek</code> converts, or rather, transliterates characters written in an arbitrary romanisation into greek letters. <code class="example">greek-to-latin</code> converts them back
        <details class="dropdown-group">
        <summary class="dropdown-btn">Reveal</summary>

        <table class="styled-table">
          <thead>
            <tr>
              <th>Latin</th>
              <th>Greek</th>
            </tr>
          </thead>
          <tbody>
            <tr><td>a</td><td>α</td></tr>
            <tr><td>á</td><td>ά</td></tr>
            <tr><td>à</td><td>ὰ</td></tr>
            <tr><td>e</td><td>ε</td></tr>
            <tr><td>é</td><td>έ</td></tr>
            <tr><td>è</td><td>ὲ</td></tr>
            <tr><td>ẹ</td><td>η</td></tr>
            <tr><td>ẹ́</td><td>ή</td></tr>
            <tr><td>ẹ̀</td><td>ὴ</td></tr>
            <tr><td>i</td><td>ι</td></tr>
            <tr><td>í</td><td>ί</td></tr>
            <tr><td>ì</td><td>ὶ</td></tr>
            <tr><td>o</td><td>ο</td></tr>
            <tr><td>ó</td><td>ό</td></tr>
            <tr><td>ò</td><td>ὸ</td></tr>
            <tr><td>ọ</td><td>ω</td></tr>
            <tr><td>ọ́</td><td>ώ</td></tr>
            <tr><td>ọ̀</td><td>ὼ</td></tr>
            <tr><td>u</td><td>υ</td></tr>
            <tr><td>ú</td><td>ύ</td></tr>
            <tr><td>ù</td><td>ὺ</td></tr>

            <tr><td>b</td><td>β</td></tr>
            <tr><td>d</td><td>δ</td></tr>
            <tr><td>f</td><td>φ</td></tr>
            <tr><td>g</td><td>γ</td></tr>
            <tr><td>k</td><td>κ</td></tr>
            <tr><td>l</td><td>λ</td></tr>
            <tr><td>m</td><td>μ</td></tr>
            <tr><td>n</td><td>ν</td></tr>
            <tr><td>p</td><td>π</td></tr>
            <tr><td>r</td><td>ρ</td></tr>
            <tr><td>s</td><td>σ</td></tr>
            <tr><td>t</td><td>τ</td></tr>
            <tr><td>x</td><td>χ</td></tr>
            <tr><td>z</td><td>ζ</td></tr>
            <tr><td>q</td><td>ξ</td></tr>
            <tr><td>þ</td><td>θ</td></tr>
            <tr><td>ṕ</td><td>ψ</td></tr>

            <tr><td>c</td><td>ϛ</td></tr>
            <tr><td>č</td><td>ͷ</td></tr>
            <tr><td>h</td><td>ͱ</td></tr>
            <tr><td>j</td><td>ϳ</td></tr>
            <tr><td>š</td><td>ϸ</td></tr>
            <tr><td>w</td><td>ϝ</td></tr>

          </tbody>
        </table>


        </details>
          
      </li>

      </ul>

      <h3 id="nescaTargetMark"><a class="head-num">17.2</a>Target-mark</h3>
      <p>A target-mark is a reference to the captured <code class="example">TARGET</code> graphemes. It cannot be used in <code class="example">TARGET</code>. This uses a less-than sign and a capital t <code class="example">&T</code>.</p>
      <p>Here are some examples where target-mark is employed:</p>
      <p><b>Full reduplication</b>:</p>
      <div class="prog-pre">  <span class="regexp">&</span> <span class="link">-></span> <span class="catkey">&T&T</span>
<span class="comment">; malak ==&gt; malakmalak</span></div>
      
      <p>"<b>Haplology</b>":</p>
      <div class="prog-pre">  <span class="regexp">{</span><span class="catkey">C</span><span class="regexp">}</span><span class="regexp">{</span><span class="catkey">V</span><span class="regexp">}</span><span class="regexp">(</span><span class="catkey">B</span><span class="regexp">)</span> <span class="link">-></span> <span class="operator">^</span> <span class="link">/</span> <span class="link">_</span><span class="catkey">&T</span>
<span class="comment">; haplology ==> haplogy</span></div>
      <p><b>Reject a word when a word-initial consonant is identical to the next consonant</b>:</p>
      <div class="prog-pre">  <span class="catkey">C</span> <span class="link">-></span> <span class="operator">0</span> <span class="link">/</span> <span class="regexp">#</span><span class="link">_</span><span class="regexp">&[</span><span class="catkey">C</span><span class="regexp">]</span><span class="catkey">&T</span></div>

      <h3 id="nescaMetathesisMark"><a class="head-num">17.3</a>Metathesis-mark</h3>
      <p>Simple metathesis involves a less-than-sign and a capital m <code class="example">&M</code> in <code class="example">REPLACEMENT</code>. This will swap the first and last grapheme from the captured <code class="example">TARGET</code> graphemes:</p>
      <div class="prog-pre"><span class="comment">; Swap a plosive and nasal stop</span>
  <span class="regexp">{</span>p<span class="link">,</span> t<span class="link">,</span> k<span class="link"></span><span class="regexp">}</span><span class="regexp">{</span>m<span class="link">,</span> n<span class="regexp">}</span> <span class="link">-></span> <span class="catkey">&M</span><br><span class="comment">; apma ==> ampa</span></div>

      <p>Since metathesis reference is swapping the first and last grapheme, we can effectively simulate long-distance metathesis using an anythings-mark:</p>

      <div class="prog-pre"><span class="comment">; Simulate Old Spanish "Hyperthesis"</span>
  r<span class="regexp">&</span>l <span class="link">-></span> <span class="catkey">&M</span><br><span class="comment">; parabla ==> palabra</span></div>

      <h3 id="nescaEmptyMark"><a class="head-num">17.4</a>Empty-mark</h3>
      <p>An Empty-mark using <code class="example">&E</code>, inserts an 'empty' grapheme into the captured <code class="example">TARGET</code> graphemes. It is only allowed in <code class="example">TARGET</code></p>

      <p>One use for it is a trick to make one-place long-distance metathesis work, for example:</p>

      <div class="prog-pre"><span class="comment">; The &lt;r&gt; of a plosive + &lt;r&gt; cluster is moved</span>
<span class="comment">; between a word initial plosive and a vowel</span>
  <span class="catkey">&E</span><span class="regexp">{</span>a<span class="link">,</span>e<span class="link">,</span>i<span class="link">,</span>o<span class="link">,</span>u<span class="regexp">}</span><span class="regexp">&[<span class="operator">^</span></span><span class="regexp">{</span>p<span class="link">,</span>t<span class="link">,</span>k<span class="regexp">}</span>r<span class="regexp">]</span><span class="regexp">{</span>p<span class="link">,</span>t<span class="link">,</span>k<span class="regexp">}</span>r <span class="link">-></span> <span class="catkey">&M</span> <span class="link">/</span> <span class="regexp">#</span><span class="regexp">{</span>p<span class="link">,</span>t<span class="link">,</span>k<span class="regexp">}</span><span class="link">_</span>
<span class="comment">; kotatros -> krotatos</span></div>

      <h3 id="nescaReference"><a class="head-num">17.5</a>Reference</h3>
      <p>Sometimes graphemes must be copied or asserted to be a certain grapheme between other graphemes. This is the purpose of 'reference'. Reference is fairly straightforward, but there is a lot of jargon and different behaviour between fields to explain.</p>

      <h4 id="nescaSingularReference"><a class="head-num">17.5.1</a>Reference of singular grapheme</h4>

      <p>A grapheme (or graphemes) are bound to a reference using a 'reference-capture', to the right of some grapheme. A reference-capture looks like <code class='example'>=</code> followed by a single-digit positive number. This number is called the 'reference-key' of the reference. The grapheme (or graphemes) bound to the reference is called the 'reference-value'.</p>

      <p>The key behaviours of reference-capture are:</p>
      <ul class="paragraphian">
        <li>If there are no graphemes to be captured by the reference-capture, nothing is captured</li>
        <li>A Reference forgets its reference-value in-between rules. References do not persist between rules</li>
        <li>You can have up to nine references per rule</li>
        <li>A reference's reference-value can be overwritten with a new reference-capture</li>
        <li>For reference-capture in conditions, a grapheme is captured only if that condition is met</li>
      </ul>

      <p>The captured grapheme can then be reproduced elsewhere in the rule with a 'reference-mark', even before the reference-capture. The reference-mark invokes the reference-key of a reference.</p>

      <p>The key behaviours of reference-mark are:</p>
      <ul class="paragraphian">
        <li>A reference-mark may not be used in the <code class='example'>TARGET</code> of a rule.</li>
        <li>In each condition or exception of a rule, a reference-mark cannot be used before content has been bound to its reference with a reference-capture. For example <code class="example">a -> e / 1x=1_</code> is invalid, and so is <code class="example">a -> e / 1_x=1</code>. Reference is not recursive in conditions and exceptions.</li>
        <li>If a reference-mark is used where a reference-capture has not captured anything yet, it fails silently and outputs the number of the backrefence.</li>
      </ul>

      <p>Here are some examples:</p>

      <div class="prog-pre"><span class="comment">; Delete &lt;ʔ&gt; between identical vowels</span>
  ʔ <span class="link">-&gt;</span> <span class="operator">^</span> <span class="regexp">/</span> <span class="catkey">[+vowel]</span><span class="regexp">=1</span><span class="link">_</span><span class="catkey">1</span>
<span class="comment">; baʔaʔe ==> baaʔe</span></div>

      <p>In the rule above, we are binding the <code class='example'>[+vowel]</code> feature-matrix to the reference <code class='example'>1</code>, by appending <code class='example'>=1</code> to it. Whatever this grapheme from <code class='example'>[+vowel]</code> is when the condition is met, is captured as the value of <code class='example'>1</code>. Then the value of backrefence <code class='example'>1</code> is inserted into <code class='example'>AFTER</code> by invoking its reference-mark.</p>

      <div class="prog-pre"><span class="comment">; Insert an 'echo vowel' at the end of &lt;ʔ&gt; final words</span>
  <span class="operator">^</span> <span class="link">-&gt;</span> <span class="catkey">1</span> <span class="regexp">/</span> <span class="regexp">{</span><span class="catkey">V</span><span class="regexp">}</span><span class="regexp">=1</span>ʔ<span class="link">_</span><span class="regexp">#</span>
<span class="comment">; foobaʔ ==&gt; foobaʔa</span></div>

      <p>In the rule above, we are binding the <code class='example'>V</code> category to the reference <code class='example'>1</code>, by appending <code class='example'>=1</code> to it. Whatever this grapheme from <code class='example'>V</code> is when the condition is met is the value of <code class='example'>1</code>. Then the value of <code class='example'>1</code> is inserted into <code class='example'>REPLACEMENT</code> by invoking its reference-mark.</p>

      <h4 id="nescaReferenceSequence"><a class="head-num">17.5.2</a>Reference of grapheme sequence</h4>

      <p>Now that 'reference-capture' and 'reference-mark' has been (hopefully) introduced and explained adequately, let's explain how to capture and reference a sequence of graphemes.</p>

      <p>To start capturing a sequence, you use a 'start-reference-capture', <code class="example">&=</code> before the graphmemes to be captured. Then at the end of the graphemes to be captured, a 'reference-capture' is used to bind those graphemes to a reference:</p>

      <div class="prog-pre"><span class="comment">; Insert an 'echo double vowel' at the end of vowel + vowel + &lt;ʔ&gt; final words</span>
  <span class="operator">^</span> <span class="link">-&gt;</span> <span class="catkey">1</span> <span class="regexp">/</span> <span class="regexp">&=</span><span class="regexp">{</span><span class="catkey">V</span><span class="regexp">}</span><span class="regexp">{</span><span class="catkey">V</span><span class="regexp">}</span><span class="regexp">=1</span>ʔ<span class="link">_</span><span class="regexp">#</span>
<span class="comment">; foobaaʔ ==&gt; foobaaʔaa</span></div>
      
      <h3 id="nescaAssociatemes"><a class="head-num">17.6</a>Associatemes</h3>
      <p>If your language encodes tone, stress, breathy voice, or other phonological features directly on vowels, you'll often need to target a particular grapheme across its variants.</p>
      <p>One method is to target each variant manually:</p>

      <div class="prog-pre">  <span class="regexp">{</span>a<span class="link">,</span> á<span class="link">,</span> à<span class="regexp">}</span> <span class="link">-&gt;</span> <span class="regexp">{</span>e<span class="link">,</span> é<span class="link">,</span> è<span class="regexp">}</span><br><span class="comment">; daná ==&gt; dené</span></div>

      <p>This workaround uses alternators, but lacks semantic clarity and scalability, and is outright tedious.</p>
      <p>To solve this, are 'associatemes' -- aligned variant graphemes associated with their base grapheme, and other associated graphemes -- other SCAs might use the terms "floating diacritics" or "autosegmentals". These allow you to target all forms of a grapheme with a single token. To set up associatemes, they must be stated in the <code class="example">graphemes</code> directive with the base associateme set of an entry inside curly braces, and each variant set in curly braces with a &lt; to the left of the base set, or another variant set, like so:</p>
      
      <div class="prog-pre"><span class="directive">graphemes</span><span class="link">: <span class="regexp">
  {</span></span>a<span class="link">,</span> e<span class="link">,</span> i<span class="link">,</span> o<span class="link">,</span> u<span class="regexp">}</span><span class="regexp">&lt;</span><span class="regexp">{</span>á<span class="link">,</span> é<span class="link">,</span> í<span class="link">,</span> ó<span class="link">,</span> ú<span class="regexp">}</span><span class="regexp">&lt;</span><span class="regexp">{</span>à<span class="link">,</span> è<span class="link">,</span> ì<span class="link">,</span> ò<span class="link">,</span> ù<span class="regexp">}</span></div>

      <p>The behaviour of associatemes are:</p>
      <ul class="paragraphian">
        <li>Each grouping must contain an equal number of graphemes, aligned by position. This creates a traceable overlay across tone, stress, and other features</li>
        <li>This does not mean that each variant must be different by means of diacritics, they are arbitrarily variant. For example <code class="example">{a,b,c}&lt;{x,y,z}</code> is valid</li>
        <li>This does not mean that we can have only one grouping set. For example <code class="example">{a,i,o}&lt;{á,í,ó}, {a,b,c}&lt;{x,y,z}</code> is valid</li>
      </ul>

      <p>In a rule, you then put a tilde after the grapheme to mark it as a base associateme. This is called a 'based-mark'. For example:</p>
      

            <div class="prog-pre"><span class="directive">graphemes</span><span class="link">: <span class="regexp">
  {</span></span>a<span class="link">,</span> e<span class="link">,</span> i<span class="link">,</span> o<span class="link">,</span> u<span class="regexp">}</span><span class="regexp">&lt;</span><span class="regexp">{</span>á<span class="link">,</span> é<span class="link">,</span> í<span class="link">,</span> ó<span class="link">,</span> ú<span class="regexp">}</span><span class="regexp">&lt;</span><span class="regexp">{</span>à<span class="link">,</span> è<span class="link">,</span> ì<span class="link">,</span> ò<span class="link">,</span> ù<span class="regexp">}</span>
<span class="directive">stage</span><span class="link">:</span>
  a<span class="regexp">~</span> <span class="link">-&gt;</span> e<span class="regexp">~</span><br><span class="comment">; daná ==&gt; dené</span></div>
      
      <p>This transform targets all variants of <code class="example">a</code> and carries over that association to <code class="example">e</code>.</p>

    </section>

  </div>

  <footer>
    <ol class="breadcrumbs">
      <li>
        <a href="#myNav">Return to top</a>
      </li>
    </ol>
  </footer>
  
</body>
</html>